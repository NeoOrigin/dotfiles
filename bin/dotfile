#!/bin/ksh
#####################################################################################################################
#
# Name:          dotfile
# Developer:     Philip Bowditch
# Created:       20151110
# Description:   
#
#####################################################################################################################


#-- Constants -------------------------------------------------------------------------------------------------------

ERR_UNKNOWN_CMD=1
ERR_INVALID_LOG_PATH=2
ERR_ROLE_NOT_FOUND=3

ERR_AUTHENTICATION_FAILED=10
ERR_AUTHORIZATION_FAILED=20

SUCCESS=0


#-- Functions -------------------------------------------------------------------------------------------------------

function usage
{
    ####################################################################################
    #
    # Description:  Print high level usage for this script
    # 
    ####################################################################################

    cat <<EOF
usage: dotfile <command> <options>

Where <command> is one of the following:

    request           - Applys a role    
    release           - Releases/removes a role
    reset             - Removes all roles
    describe          - Output basic information about a role
    list              - Prints out all supported roles
    help              - Prints out help for a given <command>
    
Where 

Where <options> consist of 1 or more of the following:

    ( -A | --no-aliases      )                  - Do not include role aliase definitions
    ( -N | --no-env          )                  - Do not inherit environment variables from the role
    ( -F | --no-files        )                  - Do not initialise files copies from roles
    ( -K | --no-link         )                  - Do not initialise symbolic links
    ( -D | --no-dependencies )                  - Do not include dependencies from other roles/products
    ( -P | --no-paths        )                  - Do not include role directories to PATH and LD_LIBRARY_PATH environment variables
    ( -S | --no-script       )                  - Do not execute role scripts
    ( -x | --debug           )                  - Force debugging extra info to the log file
    ( -X | --trace           )                  - Force command tracing along with debug information
    ( -h | --help            )                  - Prints out this usage message

NOTE: The order of command line options is important and will be processed left to right.  Therefore any global options
that will affect how you want the command to work should be specified as early as possible e.g. --debug or --catalog.  

Examples

To allocate an etl developer role you would source this script in your .profile as follows

    . dotfile request etl

To deactivate a role you must release them in the reverse order they were applied

    . dotfile release ddl_developer && . dotfile release etl
    
Note although the chaining of roles is quite valid we would suggest instead creating a custom role where
the 2 or more roles you wish to allocate are specified as dependencies.  Not only does this make the 
command easier to manage and remember but will also allocate / deallocate in a consistent manner.  
    
As a handy shortcut the following will release all roles appropriately

    . dotfile release @
    
or

    . dotfile reset

EOF
}

function log_it
{
    ####################################################################################
    #
    # Description:  Logs a message to a file
    # Parameters:   1 - The severity of the message, e.g. INFO, WARN, DEBUG, ERROR
    #               2 - The category identifier for this log message
    #               * - The message
    # Requires:     USER         - The login name of the current user
    #               DOTFILES_LOG - The path to a log file to write to
    #               3 - Used for identification the pid of the process being run
    # 
    ####################################################################################

    LEVEL="$1"
    CATEGORY="$2"
    shift 2

    [[ -n "$DOTFILES_LOG" ]] && printf "%s: %s: %s: %s: %s\n" "$(date +%Y%m%d%H%M%S)" "${USER}" $$ "${CATEGORY}" "$@" >> "$DOTFILES_LOG"
}

function get_env
{
    env
}

function read_config
{
    ####################################################################################
    #
    # Description:  Outputs the contents of a config file, this will strip out blank
    #               linse and comments
    # Parameters:   The config file to read
    # 
    ####################################################################################

    grep -v "^#" "$1" | grep -v "^\$"
}

function reverse_lines
{
    ####################################################################################
    #
    # Description:  Reverses the lines on stdin
    # Parameters:   None
    # 
    ####################################################################################
    
    # tac is not cross platform, awk is more likely to be
    #tac
    awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }'
}

function reverse_words
{
    ####################################################################################
    #
    # Description:  Reverses the words on a single line of input 
    # Parameters:   None
    # 
    ####################################################################################
    
    awk '{for(i=NF;i>0;--i)printf "%s%s",$i,(i>1?OFS:ORS)}'
}

function normalize_role
{
    ####################################################################################
    #
    # Description:  Converts afile system role name into an environment parameter based
    #               role name (file system names can contain a signficantly wider
    #               set of characters.  
    # Parameters:   1 - Optional. The role name to normalize, uses stdin if not set
    # 
    ####################################################################################
    
    if [[ $# -gt 0 ]]; then
        printf "%s\n" "$1" | tr '[a-z]' '[A-Z]' | sed 's/[.]/__DOT__/g' | sed 's/[-]/__DASH__/g' | sed 's/[ ]/__SPACE__/g'
    else
        tr '[a-z]' '[A-Z]' | sed 's/[.]/__DOT__/g' | sed 's/[-]/__DASH__/g' | sed 's/[ ]/__SPACE__/g'
    fi
}

function unnormalize_role
{
    ####################################################################################
    #
    # Description:  Converts an environment parameter role name back to a filesystem 
    #               based role name (file system names can contain a signficantly wider
    #               set of characters.  
    # Parameters:   1 - Optional. The role name to unnormalize, uses stdin if not set
    # 
    ####################################################################################
    
    if [[ $# -gt 0 ]]; then
        printf "%s\n" "$1" | sed 's/__SPACE__/ /g' | sed 's/__DASH__/-/g' | sed 's/__DOT__/./g' | tr '[A-Z]' '[a-z]'
    else
        sed 's/__SPACE__/ /g' | sed 's/__DASH__/-/g' | sed 's/__DOT__/./g' | tr '[A-Z]' '[a-z]'
    fi
}

function escape_regex
{
    ####################################################################################
    #
    # Description:  Escapes some commonly used characters used within simple regular
    #               expression matching (i.e. grep).  This is so user entered values
    #               cannot subvert a matching attempt
    # Parameters:   1 - The value to escape
    # 
    ####################################################################################
    
    if [[ $# -gt 0 ]]; then
        printf "%s\n" "$1" | sed 's/[[\.*^$/]/\\&/g'
    else
        sed 's/[[\.*^$/]/\\&/g'
    fi
}

function escape_regex_extended
{
    ####################################################################################
    #
    # Description:  Escapes some commonly used characters used within extended regular
    #               expression matching (i.e. perl or egrep).  This is so user entered
    #               values cannot subvert a matching attempt
    # Parameters:   1 - The value to escape
    # 
    ####################################################################################
    
    if [[ $# -gt 0 ]]; then
        printf "%s\n" "$1" | sed 's/[[\.*^$(){}?+|/]/\\&/g'
    else
        sed 's/[[\.*^$/]/\\&/g'
    fi
}

function get_role_path
{
    ####################################################################################
    #
    # Description:  Given a role name, returns its full path (if any)
    # Parameters:   1 - The name of the role to check for
    #               2 - The system delimited path to check
    # 
    ####################################################################################
    
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    printf "%s\n" "${ROLE_LIST}" | grep -i ".*/${NEW_ROLE}$" | head -1
}

function list_roles
{
    ####################################################################################
    #
    # Description:  Returns all roles found on the path
    # Parameters:   1 - The system delimited path-like variable to check against
    # 
    ####################################################################################
    
    ROLES_PATH="$1"

    # Find all roles installed on the machine / in known paths
    printf "%s\n" "${ROLES_PATH}" | sed 's/:/\n/g' | xargs -i find {} -maxdepth 1 -mindepth 1 2>/dev/null
}

function authenticate
{
    ####################################################################################
    #
    # Description:  Authenticates a user (TODO)
    # Parameters:   1 - The user name
    # 
    ####################################################################################
    
    return $SUCCESS
}

function validate_role
{
    ####################################################################################
    #
    # Description:  Validates a role exists and the user is allowed access
    # Parameters:   1 - The role name to validate
    #               2 - The complete list of roles to validate against
    # 
    ####################################################################################

    NEW_ROLE="$1"
    ROLE_LIST="$2"

    ROLE_FOUND=$(get_role_path "${NEW_ROLE}" "$ROLE_LIST" )

    if [[ -z "${ROLE_FOUND}" ]]; then
        printf "%s: Role [%s] is unrecognised, use %s to print out supported roles\n" ERROR "$NEW_ROLE" "$DOTFILES_HOME/dotfile list" >&2
        return $ERR_ROLE_NOT_FOUND
    fi

    "${DOTFILES_AUTHENTICATE_PATH:-true}" "$USER"
    if [[ $? -ne 0 ]]; then
        log_it ERROR REQUEST "$NEW_ROLE"
        printf "%s: Could not authenticate user [%s].  Exiting\n" ERROR "$USER" >&2
        return $ERR_AUTHENTICATION_FAILED
    fi

    "${DOTFILES_AUTHORIZE_PATH:-true}" "$USER" "$NEW_ROLE"
    if [[ $? -ne 0 ]]; then
        log_it ERROR REQUEST "$NEW_ROLE"
        printf "%s: User [%s] is not granted access to role [%s].  Exiting\n" ERROR "$USER" "$NEW_ROLE" >&2
        return $ERR_AUTHORIZATION_FAILED
    fi

    return $SUCCESS
}

function help_role
{
    NEW_CMD="$1"

    NEW_CMD_UPPER=$(printf "%s\n" "$NEW_CMD" | tr '[a-z]' '[A-Z]')
    
    case "$NEW_CMD_UPPER" in
    
        REQUEST  ) printf "%s\n" "Adds a role to the users account"
                   ;;
        RELEASE  ) printf "%s\n" "Removes a role from the users account"
                   ;;
        RESET    ) printf "%s\n" "Removes all roles from the users account"
                   ;;
        DESCRIBE ) printf "%s\n" "Outputs summary information regarding a role"
                   ;;
        LIST     ) printf "%s\n" "Outputs what roles are available"
                   ;;
        HELP     ) usage
                   ;;
        *       )  usage >&2
                   return $ERR_UNKNOWN_CMD
                   ;;

    esac

    return $SUCCESS
}

function describe_role
{
    # Describe A Role ######
    NEW_ROLE="$1"
    NEW_ROLE_ACTION="$2"
    ROLE_LIST="$3"
    
    shift 3
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done

    # Normalize for easier pattern matching etc
    NEW_ROLE_UPPER=$(normalize_role "${NEW_ROLE}")
    
    validate_role "${NEW_ROLE}" "$ROLE_LIST" || return $?

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_MAIN="$ROLE_PATH"
        
    # A role can be a script, however typically its a directory
    # defined with an entrypoint of main
    [[ -d "${ROLE_PATH}" ]] && ROLE_MAIN="${ROLE_PATH}/main"

    if [[ "$USE_LINK" == "true" ]]; then
        :
    fi

    if [[ "$USE_DEPS" == "true" ]]; then

        cat "${ROLE_PATH}/dependencies"

        if [[ $? -ne 0 ]]; then
            printf "%s: Could not output role [%s]\n" ERROR "${ROLE_PATH}" >&2
            return 4
        fi

    fi
}

function release_role
{
    NEW_ROLE="$1"
    NEW_ROLE_ACTION="$2"
    ROLE_LIST="$3"
    
    shift 3
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done

    # Normalize for easier pattern matching etc
    NEW_ROLE_UPPER=$(normalize_role "${NEW_ROLE}")
    
    # Check for shortcut of releasing all
    if [[ "${NEW_ROLE}" == "@" ]]; then
    
        # set -A APPLIED_ROLE $(env) etc is non posix compliant
        
        APPLIED_ROLE=($(get_env | grep "^DOTFILES_ADD_ROLE__" | cut -d"_" -f5- | unnormalize_role | sed 's/=/ /g' | sort -k2,2 -nr))
        #echo "1: #: ${#APPLIED_ROLE[@]}: 0: ${APPLIED_ROLE[0]}: NEW_ROLE: ${NEW_ROLE}"
        
        while [[ "${#APPLIED_ROLE[@]}" -gt 0 ]]; do

            release_role "${APPLIED_ROLE[0]}" "${NEW_ROLE_ACTION}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?

            APPLIED_ROLE=($(get_env | grep "^DOTFILES_ADD_ROLE__" | cut -d"_" -f5- | unnormalize_role | sed 's/=/ /g' | sort -k2,2 -nr))

        done
        
        return 0
    fi

    validate_role "${NEW_ROLE}" "$ROLE_LIST" || return $?
    
    # Exit if role is not ready to be released (strict ordering is important)
    ROLE_INDEX=$(get_env | grep "^DOTFILES_ADD_ROLE__${NEW_ROLE_UPPER}=" | cut -d"=" -f2)
    if [[ "${DOTFILES_ALLOCATION_INDEX}" -ne "${ROLE_INDEX}" ]]; then
        return 0
    fi

    eval unset "DOTFILES_ADD_ROLE__${NEW_ROLE_UPPER}"
    export DOTFILES_ALLOCATION_INDEX=$(( DOTFILES_ALLOCATION_INDEX - 1 ))
    
    REVERSE_EVALUATION_ORDER=$( printf "%s\n" "${DOTFILES_EVALUATION_ORDER}" | reverse_words )
    for STAGE in ${REVERSE_EVALUATION_ORDER}; do
    
        case "${STAGE}" in
        
            aliases      ) teardown_role_aliases      "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            files        ) teardown_role_files        "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            links        ) teardown_role_links        "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            dependencies ) teardown_role_dependencies "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            env          ) teardown_role_environment  "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            path         ) teardown_role_paths        "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            script       ) teardown_role_script       "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            
        esac
        
    done
}

function request_role
{
    NEW_ROLE="$1"
    NEW_ROLE_ACTION="$2"
    ROLE_LIST="$3"
    
    shift 3
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done
    
    # Normalize for easier pattern matching etc
    NEW_ROLE_UPPER=$(normalize_role "${NEW_ROLE}")
    
    # Check user has access to this role
    validate_role "${NEW_ROLE}" "$ROLE_LIST" || return $?
    
    # Exit if role is already defined, we dont request a role already granted
    ROLE_EXISTS=$(get_env | grep "^DOTFILES_ADD_ROLE__${NEW_ROLE_UPPER}=")
    if [[ -n "${ROLE_EXISTS}" ]]; then
        return 0
    fi

    # First step is to create links if configured and the role contains them
    # Second step is to inherit any common dependencies if configured and there is a dependencies file
    # last step is to inherit the environment if configured and there is an executable file
    for STAGE in ${DOTFILES_EVALUATION_ORDER}; do

        case "${STAGE}" in
        
            aliases      ) setup_role_aliases      "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            files        ) setup_role_files        "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            links        ) setup_role_links        "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            dependencies ) setup_role_dependencies "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            env          ) setup_role_environment  "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            path         ) setup_role_paths        "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            script       ) setup_role_script       "${NEW_ROLE}" "${ROLE_LIST}" ${FUNC_SWITCHES} || return $?
                           ;;
            
        esac

    done
    
    export DOTFILES_ALLOCATION_INDEX=$(( DOTFILES_ALLOCATION_INDEX + 1 ))
    eval export "DOTFILES_ADD_ROLE__${NEW_ROLE_UPPER}"="${DOTFILES_ALLOCATION_INDEX}"
}

function setup_role_aliases
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done
    
    # Quick exit if no aliases used
    [[ "$USE_ALIASES" == "false" ]] && return 0

    # Find the role in our global roles list, it should be a leaf directory
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_ALIASES="$ROLE_PATH/aliases"
    
    # Second step is to inherit any common dependencies if configured and there is a dependencies file
    if [[ -f "$ROLE_ALIASES" ]]; then
    
        # Cant use pipes as the while loop becomes a subshell in bash, variables etc are not exposed
        #read_config "$ROLE_ALIASES" | while read -r name value; do
        
        ALIASES=$(read_config "$ROLE_ALIASES" | cut -d" " -f1)
        
        # Go through all alias names, grab their value and create the alias
        for ALIAS_DEF in ${ALIASES}; do
        
            # Escape, suitable for grep
            name=$(printf "%s\n" "$ALIAS_DEF" | sed 's|\.|\\.|g')
            value=$(grep "^$name " "$ROLE_ALIASES" | tail -1 | cut -d" " -f2-)

            eval alias -- "${ALIAS_DEF}"="'${value}'"
            if [[ $? -ne 0 ]]; then
                printf "%s: Could not create alias [%s] from role [%s]\n" ERROR "${ALIAS_DEF}" "${ROLE_PATH}" >&2
                return 3
            fi

        done
        
    fi
}

function setup_role_dependencies
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done
    
    # Quick exit if no known dependencies
    [[ "$USE_DEPS" == "false" ]] && return 0

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_DEPS="$ROLE_PATH/dependencies"

    # Second step is to inherit any common dependencies if configured and there is a dependencies file
    if [[ -f "$ROLE_DEPS" ]]; then
    
        DEPS_LIST=$(grep "^role " "$ROLE_DEPS" | sed 's/ /,/g')
        
        for DEP_ROLE in ${DEPS_LIST}; do
            ROLE_NAME=$(printf "%s\n" "${DEP_ROLE}" | cut -d, -f2)

            REVERSE_FUNC_SWITCHES=""
            [[ "$USE_ENV"     == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-env"
            [[ "$USE_LINK"    == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-link"
            [[ "$USE_PATHS"   == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-paths"
            [[ "$USE_FILES"   == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-files"
            [[ "$USE_ALIASES" == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-aliases"
            [[ "$USE_SCRIPT"  == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-script"
            [[ "$DEBUG"       == "true"  ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --debug"
            [[ "$TRACE"       == "true"  ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --trace"
            
            # NOTE: We do not add an option for use dependencies, it is assumed otherwise we would not have got this far in the function
                          
            . $DOTFILES_HOME/bin/dotfile ${REVERSE_FUNC_SWITCHES} request "${ROLE_NAME}"
            if [[ $? -ne 0 ]]; then
                printf "%s: Could not add dependency [%s] from role [%s]\n" ERROR "$ROLE_NAME" "$ROLE_PATH" >&2
                return 3
            fi
            
            # Reset input parameters, there is a chance that any script we source can change these values
            # so we reset just to make sure
            NEW_ROLE="$1"
            ROLE_LIST="$2"
            #USE_ENV="$4"
            #USE_LINK="$5"
            NEW_ROLE_UPPER=$(printf "%s\n" "${NEW_ROLE}" | normalize_role)
            
            ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
            ROLE_MAIN="$ROLE_PATH"
            ROLE_LINK="${ROLE_PATH}/links"
            ROLE_DEPS="${ROLE_PATH}/dependencies"
            [[ -d "${ROLE_PATH}" ]] && ROLE_MAIN="${ROLE_PATH}/main"
            
        done

    fi
    
    return 0
}

function setup_role_environment
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done
    
    [[ "$USE_ENV" == "false" ]] && return 0

    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_ENV="$ROLE_PATH/env"
    
    # last step is to inherit the environment if configured and there is an executable file
    if [[ -f "$ROLE_ENV" ]]; then

        # Need to remove the need for a while loop as this spawns a subshell in POSIX / bash so the exports arent exposed
        #read_config "$ROLE_ENV" | while read -r action name value; do
        
        PARAMS=$(grep -E "^(set|prepend|append) " "$ROLE_ENV" | cut -d" " -f2)
        
        for PARAM in ${PARAMS}; do
        
            PARAM_SAFE=$(escape_regex_extended "$PARAM")
            line=$(grep -E "^(set|prepend|append) ${PARAM_SAFE} " "$ROLE_ENV")
            action=$(printf "%s\n" "$line" | cut -d" " -f1)
            name="$PARAM"
            value=$(printf "%s\n" "$line" | cut -d" " -f3-)

            case "$action" in
            
                set     ) eval export "${name}"="${value}"
                          if [[ $? -ne 0 ]]; then
                              printf "%s: Could not create environment variable [%s] from role [%s]\n" ERROR "${name}" "${ROLE_PATH}" >&2
                              return 3
                          fi
                          ;;
                prepend ) eval export "${name}"="${value}\$${name}"
                          if [[ $? -ne 0 ]]; then
                              printf "%s: Could not prepend environment variable [%s] from role [%s]\n" ERROR "${name}" "${ROLE_PATH}" >&2
                              return 3
                          fi
                          ;;
                append  ) eval export "${name}"="\$${name}${value}"
                          if [[ $? -ne 0 ]]; then
                              printf "%s: Could not append environment variable [%s] from role [%s]\n" ERROR "${name}" "${ROLE_PATH}" >&2
                              return 3
                          fi
                          ;;
            
            esac

        done

    fi

    return 0
}

function setup_role_script
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done
    
    [[ "$USE_SCRIPT" == "false" ]] && return 0

    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_MAIN="$ROLE_PATH"
    
    # Incase the base path is a directory then we assume there might be a main file/script
    [[ -d "${ROLE_PATH}" ]] && ROLE_MAIN="${ROLE_PATH}/main"

    
    # last step is to inherit the environment if configured and there is an executable file
    if [[ -f "$ROLE_MAIN" ]]; then

        ${DEBUG} && log_it DEBUG CALL ". ${ROLE_MAIN} --setup"
        . "${ROLE_MAIN}" --setup

        if [[ $? -ne 0 ]]; then
            printf "%s: Could not run script from role [%s]\n" ERROR "${ROLE_PATH}" >&2
            return 3
        fi

    fi
    
    return 0
}

function setup_role_paths
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done

    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_BIN="$ROLE_PATH/bin"
    ROLE_LIB="$ROLE_PATH/lib"
    ROLE_FUN="$ROLE_PATH/funcs"

    if [[ "$USE_PATHS" == "true" ]]; then
    
        [[ -d "$ROLE_BIN" ]] && export PATH="$ROLE_BIN:$PATH"
        [[ -d "$ROLE_FUN" ]] && export FPATH="$ROLE_FUN:$FPATH"
        [[ -d "$ROLE_LIB" ]] && export LD_LIBRARY_PATH="$ROLE_LIB:$LD_LIBRARY_PATH"

    fi
    
    return 0
}

function setup_role_files
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done
    
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_FILE="$ROLE_PATH/files"
    
    # First step is to create links if configured and the role contains them
    if [[ "$USE_FILE" == "true" && -d "${ROLE_FILE}" ]]; then
    
        TARGETS=$(find "$ROLE_FILE" -maxdepth 1 -mindepth 1 2>/dev/null)
        
        # Go through all the files/folders found in the links folder as we need to point to them as symbolic
        # links in the users home directory
        for name in ${TARGETS}; do
        
            SHORT_NAME=$(basename "${name}")
            SHORT_NAME_SAFE=$(escape_regex "${SHORT_NAME}")
            
            BASE_PATH="${HOME}"
            
            FILES_LIST=""
            [[ -f "$ROLE_PATH/meta" ]] && FILES_LIST=$(grep -v "^file ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3)
            [[ -n "${FILES_LIST}" ]] && BASE_PATH="${FILES_LIST}"
            
            FILES_MANAGED=$(grep -v "^${SHORT_NAME_SAFE} " "${BASE_PATH}/.dotfile.managed")
            ACTUAL_VALUE="-"
            
            # Determines whether we need to copy the file (ie we dont copy a file if it already exists)
            FILE_EXISTS=false
            IS_MANAGED=false
            FILE_MATCHES=false
            META_MATCHES=false
            
            [[ -f "${BASE_PATH}/${SHORT_NAME}" ]] && FILE_EXISTS=true
            [[ -n "${FILES_MANAGED}" ]] && IS_MANAGED=true
            
            # If we appear to have a copy of the file already we check the contents if we can
            if ${FILE_EXISTS}; then

                CKSUM_METHOD=""
                [[ -f "$ROLE_PATH/meta" ]] && CKSUM_METHOD=$(grep -v "^hash ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3)
                CKSUM_VALUE=""
                [[ -f "$ROLE_PATH/meta" ]] && CKSUM_VALUE=$(grep -v "^hash ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f4-)
                
                case "${CKSUM_METHOD}" in
                
                    sha1sum   ) ACTUAL_VALUE=$(sha1sum   "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    sha224sum ) ACTUAL_VALUE=$(sha224sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    sha256sum ) ACTUAL_VALUE=$(sha256sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    sha384sum ) ACTUAL_VALUE=$(sha384sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    sha512sum ) ACTUAL_VALUE=$(sha512sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    md5sum    ) ACTUAL_VALUE=$(md5sum    "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    force     ) ACTUAL_VALUE="force"
                                ;;
                    skip      ) ACTUAL_VALUE="skip"
                                ;;
                
                esac
                
                COMPARE_RESULT=1
                
                if [[ "$ACTUAL_VALUE" == "force" ]]; then
                    COMPARE_RESULT=1
                elif [[ "$ACTUAL_VALUE" == "skip" ]]; then
                    COMPARE_RESULT=0
                elif [[ -z "${ACTUAL_VALUE}" || "${ACTUAL_VALUE}" == "-" ]]; then 
                    cmp "${BASE_PATH}/${SHORT_NAME}" "${name}" 2>/dev/null
                    COMPARE_RESULT=$?
                elif [[ "CKSUM_VALUE" == "$ACTUAL_VALUE"  ]]; then
                    COMPARE_RESULT=0
                fi
                
                # Perform quick check, nopoint rebuilding link if its going to be the same
                # Also prevents danger that an already running processes requires the presence if this link
                # you dont want it dissappearing even for a millisecond just because you logged in
                [[ $COMPARE_RESULT -eq 0 ]] && FILE_MATCHES=true
                
                if [[ "$IS_MANAGED" == "true" ]]; then
                    MANAGED_CKSUM=$(printf "%s\n" "${FILES_MANAGED}" | cut -d" " -f2)
                    
                    [[ "$MANAGED_CKSUM" == "$ACTUAL_VALUE" ]] && META_MATCHES=true
                fi

            fi
            
            RM_FILE=true
            RM_ENTRY=true
            COPY_FILE=true
            ADD_ENTRY=true
            
            # Generally if the file exists it really doesnt matter, we create from scratch (cant delete if doesnt exist though)
            if [[ "${FILE_EXISTS}" == "false" ]]; then
                RM_FILE=false
            else
            
                if [[ "${FILE_MATCHES}" == "true" ]]; then
                    
                    # No point removing a file that matches what we expect
                    RM_FILE=false
                    COPY_FILE=false
                    
                    # If file is the same, and metadata is the same then no need to do anything
                    if [[ "$META_MATCHES" == "true" ]]; then
                    
                        RM_ENTRY=false
                        ADD_ENTRY=false
                        
                    fi
                
                else
                
                    # File exists but not managed, dont touch it incase a developer put it there
                    if [[ "$META_MATCHES" == "false" ]]; then
                    
                        RM_FILE=false
                        COPY_FILE=false
                        RM_ENTRY=false
                        ADD_ENTRY=false
                        
                    fi
                
                fi
                
            fi
                    
            if [[ "${RM_ENTRY}" == "true" ]]; then
                
                # Remove the link, ready to rebuild
                ${DEBUG} && log_it DEBUG CLEANUP "grep -v '^${SHORT_NAME_SAFE} ' '${BASE_PATH}/.dotfile.managed' > '${BASE_PATH}/.dotfile.managed2'"
                grep -v "^${SHORT_NAME_SAFE} " "${BASE_PATH}/.dotfile.managed" > "${BASE_PATH}/.dotfile.managed2"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not remove file from role [%s]\n" ERROR "${ROLE_PATH}" >&2
                    return 4
                fi
                
                ${DEBUG} && log_it DEBUG CLEANUP "mv '${BASE_PATH}/.dotfile.managed2' '${BASE_PATH}/.dotfile.managed'"
                mv "${BASE_PATH}/.dotfile.managed2" "${BASE_PATH}/.dotfile.managed"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not add file to role [%s]\n" ERROR "${ROLE_PATH}" >&2
                    return 4
                fi
                
            fi
            
            if [[ "${RM_FILE}" == "true" ]]; then
                
                # Remove the link, ready to rebuild
                ${DEBUG} && log_it DEBUG CLEANUP "rm -f '${BASE_PATH}/${SHORT_NAME}'"
                rm -f "${BASE_PATH}/${SHORT_NAME}"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not remove file from role [%s]\n" ERROR "${ROLE_PATH}" >&2
                    return 4
                fi
                
            fi
            
            if [[ "${ADD_ENTRY}" == "true" ]]; then
                
                # Record that we are now managing this file
                ${DEBUG} && log_it DEBUG COPYING "printf '%s %s %s\n' '${SHORT_NAME}' '${ACTUAL_VALUE}' '${name}' >> '${BASE_PATH}/.dotfile.managed'"
                printf "%s %s %s\n" "${SHORT_NAME}" "${ACTUAL_VALUE}" "${name}" >> "${BASE_PATH}/.dotfile.managed"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not add metadata to [%s] to manage file copy from role [%s]\n" ERROR "${BASE_PATH}/${SHORT_NAME}" "${ROLE_PATH}" >&2
                    return 5
                fi
                
            fi
            
            if [[ "${COPY_FILE}" == "true" ]]; then
            
                ${DEBUG} && log_it DEBUG COPYING "cp --recursive --archive '${name}' '${BASE_PATH}/${SHORT_NAME}'"
                cp --recursive --archive "${name}" "${BASE_PATH}/${SHORT_NAME}"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not add file from role [%s]\n" ERROR "${ROLE_PATH}" >&2
                    return 5
                fi
                
            fi
            
        done
        
    fi
    
    return 0
}

function setup_role_links
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done
    
    # Quick exit
    [[ "$USE_LINK" == "false" ]] && return 0

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_LINK="$ROLE_PATH/links"
    
    # First step is to create links if configured and the role contains them
    if [[ -d "${ROLE_LINK}" ]]; then
    
        TARGETS=$(find "$ROLE_LINK" -maxdepth 1 -mindepth 1 2>/dev/null)

        # Go through all the files/folders found in the links folder as we need to point to them as symbolic
        # links in the users home directory
        for name in ${TARGETS}; do
        
            SHORT_NAME=$(basename "${name}")
            SHORT_NAME_SAFE=$(escape_regex_extended "${SHORT_NAME}")

            # Determines whether we need to create the link (ie we dont rebuild a link if it already exists)
            REBUILD_LINK=true
            
            BASE_PATH="${HOME}"
            
            LINKS_LIST=""
            CHMOD_PERMS=""
            if [[ -f "$ROLE_PATH/meta" ]]; then
            
                OVERRIDES=$(grep -E "^(chmod|link) ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta")

                CHMOD_PERMS=$(printf "%s\n" "${OVERRIDES}" | grep "^chmod " | head -1 | cut -d" " -f3)
                LINKS_LIST=$( printf "%s\n" "${OVERRIDES}" | grep "^link "  | head -1 | cut -d" " -f3)
                
                [[ -n "${LINKS_LIST}" ]] && BASE_PATH="${LINKS_LIST}"
            fi
            
            # Check the link already exists, if it does we may need to repoint it
            if [[ -L "${BASE_PATH}/${SHORT_NAME}" ]]; then

                ORIG_TARGET=$(readlink --canonicalize "${BASE_PATH}/${SHORT_NAME}")
                NEW_TARGET=$(readlink --canonicalize "${name}")
                
                # Perform quick check, nopoint rebuilding link if its going to be the same
                # Also prevents danger that an already running processes requires the presence if this link
                # you dont want it dissappearing even for a millisecond just because you logged in
                if [[ "${ORIG_TARGET}" == "${NEW_TARGET}" ]]; then
                    REBUILD_LINK=false
                else
                
                    # Remove the link, ready to rebuild
                    ${DEBUG} && log_it DEBUG CLEANUP "rm -f '${BASE_PATH}/${SHORT_NAME}'"
                    rm -f "${BASE_PATH}/${SHORT_NAME}"
                    if [[ $? -ne 0 ]]; then
                        printf "%s: Could not reset symbolic links from role [%s]\n" ERROR "${ROLE_PATH}" >&2
                        return 4
                    fi
                    
                fi

            fi
            
            # Only create a link if there is nothing there i.e. above we only checked if a symbolic link existed that
            # needs repointing, however if a file is there then user must have wanted an override of their own
            # we do not delete customer overrides
            if [[ "${REBUILD_LINK}" == "true" && ! -e "${BASE_PATH}/${SHORT_NAME}" ]]; then
            
                ${DEBUG} && log_it DEBUG LINKING "ln -s '${name}' '${BASE_PATH}/${SHORT_NAME}'"
                ln -s "${name}" "${BASE_PATH}/${SHORT_NAME}"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not add symbolic links from role [%s]\n" ERROR "${ROLE_PATH}" >&2
                    return 5
                fi
                
                if [[ -n "$CHMOD_PERMS" ]]; then
                    CURR_PERMS=$(find "${BASE_PATH}" -mindepth 1 -maxdepth 1 -name "${SHORT_NAME}" -printf "%#m\n")
                    
                    [[ "$CURR_PERMS" != "$CHMOD_PERMS" ]] && chmod "$CHMOD_PERMS" "${BASE_PATH}/${SHORT_NAME}"
                fi
                
            fi
            
        done
        
    fi
    
    return 0
}

function teardown_role_aliases
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done
    
    [[ "$USE_ALIASES" == "false" ]] && return 0

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_ALIASES="$ROLE_PATH/aliases"
    
    # Second step is to inherit any common dependencies if configured and there is a dependencies file
    if [[ -f "$ROLE_ALIASES" ]]; then
    
        # Cant use pipes as the while loop becomes a subshell in bash, variables etc are not exposed
        #read_config "$ROLE_ALIASES" | while read -r name value; do
        
        ALIASES=$(read_config "$ROLE_ALIASES" | reverse_lines | cut -d" " -f1)
        
        for ALIAS_DEF in ${ALIASES}; do
        
            unalias -- "${ALIAS_DEF}" 2>/dev/null
            # No point monitoring for error, alias wont be there
            
        done
        
    fi
}

function teardown_role_dependencies
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done
    
    [[ "$USE_DEPS" == "false" ]] && return 0

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_DEPS="$ROLE_PATH/dependencies"
    
    # Second step is to inherit any common dependencies if configured and there is a dependencies file
    if [[ -f "$ROLE_DEPS" ]]; then
    
        DEPS_LIST=$(grep "^role " "$ROLE_DEPS" | sed 's/ /,/g' | reverse_lines)
        
        for DEP_ROLE in ${DEPS_LIST}; do
            ROLE_NAME=$(printf "%s\n" "${DEP_ROLE}" | cut -d, -f2)
            
            # Propogate command line options as we are calling the script again
            REVERSE_FUNC_SWITCHES=""
            [[ "$USE_ENV"     == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-env"
            [[ "$USE_LINK"    == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-link"
            [[ "$USE_PATHS"   == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-paths"
            [[ "$USE_FILES"   == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-files"
            [[ "$USE_ALIASES" == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-aliases"
            [[ "$USE_SCRIPT"  == "false" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-script"
            [[ "$DEBUG"       == "true"  ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --debug"
            [[ "$TRACE"       == "true"  ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --trace"
            
            
            . $DOTFILES_HOME/bin/dotfile ${REVERSE_FUNC_SWITCHES} release "${ROLE_NAME}"
            if [[ $? -ne 0 ]]; then
                printf "%s: Could not remove dependency [%s] from role [%s]\n" ERROR "${ROLE_NAME}" "${NEW_ROLE}" >&2
                return 4
            fi
            
            # Reset input parameters, there is a chance that any script we source can change these values
            # so we reset just to make sure
            NEW_ROLE="$1"
            ROLE_LIST="$2"
            #USE_ENV="$4"
            #USE_LINK="$5"
            NEW_ROLE_UPPER=$(printf "%s\n" "${NEW_ROLE}" | normalize_role)
            
            ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
            ROLE_MAIN="$ROLE_PATH"
            ROLE_LINK="${ROLE_PATH}/links"
            ROLE_DEPS="${ROLE_PATH}/dependencies"
            [[ -d "${ROLE_PATH}" ]] && ROLE_MAIN="${ROLE_PATH}/main"
            
        done
        
    fi
    
    return 0
}

function teardown_role_environment
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done

    # Quick exit
    [[ "$USE_ENV" == "false" ]] && return 0

    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_ENV="$ROLE_PATH/env"

    if [[ -f "$ROLE_ENV" ]]; then

        # Need to remove the need for a while loop as this spawns a subshell in POSIX / bash so the exports arent exposed
        #read_config "$ROLE_ENV" | while read -r action name value; do
        
        PARAMS=$(grep -E "^(set|prepend|append) " "$ROLE_ENV" | reverse_lines | cut -d" " -f2)
        
        for PARAM in ${PARAMS}; do
        
            PARAM_SAFE=$(escape_regex_extended "${PARAM}")
            line=$(grep -E "^(set|prepend|append) $PARAM_SAFE " "$ROLE_ENV")
            action=$(printf "%s\n" "$line" | cut -d" " -f1)
            name="$PARAM"
            value=$(printf "%s\n" "$line" | cut -d" " -f3-)
            new_value="$value"
            
            case "$action" in
            
                set     ) new_value=""
                
                          unset "${name}"
                          if [[ $? -ne 0 ]]; then
                              printf "%s: Could not unset environment variable [%s] from role [%s]\n" ERROR "${name}" "${ROLE_PATH}" >&2
                              return 3
                          fi
                          ;;
                prepend ) #eval export ${name}=${value}${name}
                          value_interpreted=$(eval printf "%s" "${value}")
                          new_value=$(env | grep "^${name}=" | sed "s|^${name}=||g" | sed "s|^${value_interpreted}||g")
                          
                          export "${name}"="$new_value"
                          if [[ $? -ne 0 ]]; then
                              printf "%s: Could not pop environment variable [%s] from role [%s]\n" ERROR "${name}" "${ROLE_PATH}" >&2
                              return 3
                          fi
                          ;;
                append  ) #eval export ${name}=${value}${name}
                          value_interpreted=$(eval printf "%s" "${value}")
                          new_value=$(env | grep "^${name}=" | sed "s|^${name}=||g" | sed "s|${value_interpreted}$||g")
                          
                          export "${name}"="$new_value"
                          if [[ $? -ne 0 ]]; then
                              printf "%s: Could not shift environment variable [%s] from role [%s]\n" ERROR "${name}" "${ROLE_PATH}" >&2
                              return 3
                          fi
                          ;;
            
            esac
            
            # Check if user wants all unset variables to be unset or remain as blank
            if [[ "$DOTFILES_UNSET_EMPTY_VARIABLES" == "true" && -z "${new_value}" ]]; then
                unset "${name}"
            fi
            
        done

    fi
    
    return 0
}

function teardown_role_script
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done

    [[ "$USE_SCRIPT" == "false" ]] && return 0

    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_MAIN="$ROLE_PATH"

    # Incase the base path is a directory then we assume there might be a main file/script
    [[ -d "${ROLE_PATH}" ]] && ROLE_MAIN="${ROLE_PATH}/main"

    if [[ -f "$ROLE_MAIN" ]]; then

        ${DEBUG} && log_it DEBUG CALL ". ${ROLE_MAIN} --teardown"
        . "${ROLE_MAIN}" --teardown

        if [[ $? -ne 0 ]]; then
            printf "%s: Could not release role [%s]\n" ERROR "${ROLE_PATH}" >&2
            return 3
        fi

    fi
    
    return 0
}

function teardown_role_paths
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done

    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_BIN="$ROLE_PATH/bin"
    ROLE_LIB="$ROLE_PATH/lib"
    ROLE_FUN="$ROLE_PATH/funcs"

    if [[ "$USE_PATHS" == "true" ]]; then
    
        [[ -d "$ROLE_BIN" ]] && export PATH=$(printf "%s\n" "$PATH" | sed "s|^$ROLE_BIN:||g")
        [[ -d "$ROLE_FUN" ]] && export FPATH=$(printf "%s\n" "$FPATH" | sed "s|^$ROLE_FUN:||g")
        [[ -d "$ROLE_LIB" ]] && export LD_LIBRARY_PATH=$(printf "%s\n" "$LD_LIBRARY_PATH" | sed "s|^$ROLE_LIB:||g")

    fi
    
    return 0
}

function teardown_role_files
{
    return 0
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done
    
    [[ "$USE_FILE" == "false" ]] && return 0

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_FILE="$ROLE_PATH/files"
    
    # First step is to create links if configured and the role contains them
    if [[ -d "${ROLE_FILE}" ]]; then
    
        TARGETS=$(find "$ROLE_FILE" -maxdepth 1 -mindepth 1 2>/dev/null | reverse_lines)
        
        # Go through all the files/folders found in the links folder as we need to point to them as symbolic
        # links in the users home directory
        for name in ${TARGETS}; do
        
            SHORT_NAME=$(basename "${name}")
            
            BASE_PATH="${HOME}"
            
            FILES_LIST=""
            [[ -f "$ROLE_PATH/meta" ]] && FILES_LIST=$(grep -v "^file ${SHORT_NAME} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3)
            [[ -n "${FILES_LIST}" ]] && BASE_PATH="${FILES_LIST}"
            
            FILES_MANAGED=$(grep -v "^${SHORT_NAME} " "${BASE_PATH}/.dotfile.managed")
            ACTUAL_VALUE="-"
            
            # Determines whether we need to copy the file (ie we dont copy a file if it already exists)
            FILE_EXISTS=false
            IS_MANAGED=false
            FILE_MATCHES=false
            META_MATCHES=false
            
            [[ -f "${BASE_PATH}/${SHORT_NAME}" ]] && FILE_EXISTS=true
            [[ -n "${FILES_MANAGED}" ]] && IS_MANAGED=true
            
            # If we appear to have a copy of the file already we check the contents if we can
            if ${FILE_EXISTS}; then

                CKSUM_METHOD=""
                [[ -f "$ROLE_PATH/meta" ]] && CKSUM_METHOD=$(grep -v "^hash ${SHORT_NAME} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3)
                CKSUM_VALUE=""
                [[ -f "$ROLE_PATH/meta" ]] && CKSUM_VALUE=$(grep -v "^hash ${SHORT_NAME} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f4-)
                
                case "${CKSUM_METHOD}" in
                
                    sha1sum   ) ACTUAL_VALUE=$(sha1sum   "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    sha224sum ) ACTUAL_VALUE=$(sha224sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    sha256sum ) ACTUAL_VALUE=$(sha256sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    sha384sum ) ACTUAL_VALUE=$(sha384sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    sha512sum ) ACTUAL_VALUE=$(sha512sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    md5sum    ) ACTUAL_VALUE=$(md5sum    "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                                ;;
                    force     ) ACTUAL_VALUE="force"
                                ;;
                    skip      ) ACTUAL_VALUE="skip"
                                ;;
                
                esac
                
                COMPARE_RESULT=1
                
                if [[ "$ACTUAL_VALUE" == "force" ]]; then
                    COMPARE_RESULT=1
                elif [[ "$ACTUAL_VALUE" == "skip" ]]; then
                    COMPARE_RESULT=0
                elif [[ -z "${ACTUAL_VALUE}" || "${ACTUAL_VALUE}" == "-" ]]; then 
                    cmp "${BASE_PATH}/${SHORT_NAME}" "${name}" 2>/dev/null
                    COMPARE_RESULT=$?
                elif [[ "CKSUM_VALUE" == "$ACTUAL_VALUE"  ]]; then
                    COMPARE_RESULT=0
                fi
                
                # Perform quick check, nopoint rebuilding link if its going to be the same
                # Also prevents danger that an already running processes requires the presence if this link
                # you dont want it dissappearing even for a millisecond just because you logged in
                [[ $COMPARE_RESULT -eq 0 ]] && FILE_MATCHES=true
                
                if [[ "$IS_MANAGED" == "true" ]]; then
                    MANAGED_CKSUM=$(printf "%s\n" "${FILES_MANAGED}" | cut -d" " -f2)
                    
                    [[ "$MANAGED_CKSUM" == "$ACTUAL_VALUE" ]] && META_MATCHES=true
                fi

            fi
            
            RM_FILE=true
            RM_ENTRY=true
            
            # Generally if the file exists it really doesnt matter, we create from scratch (cant delete if doesnt exist though)
            if [[ "${FILE_EXISTS}" == "false" ]]; then
                RM_FILE=false
            else
            
                if [[ "${FILE_MATCHES}" == "true" ]]; then
                    
                    # No point removing a file that matches what we expect
                    RM_FILE=false
                    COPY_FILE=false
                    
                    # If file is the same, and metadata is the same then no need to do anything
                    if [[ "$META_MATCHES" == "true" ]]; then
                    
                        RM_ENTRY=false
                        ADD_ENTRY=false
                        
                    fi
                
                else
                
                    # File exists but not managed, dont touch it incase a developer put it there
                    if [[ "$META_MATCHES" == "false" ]]; then
                    
                        RM_FILE=false
                        COPY_FILE=false
                        RM_ENTRY=false
                        ADD_ENTRY=false
                        
                    fi
                
                fi
                
            fi
                    
            if [[ "${RM_ENTRY}" == "true" ]]; then
                
                # Remove the link, ready to rebuild
                ${DEBUG} && log_it DEBUG CLEANUP "grep -v '^${SHORT_NAME} ' '${BASE_PATH}/.dotfile.managed' > '${BASE_PATH}/.dotfile.managed2'"
                grep -v "^${SHORT_NAME} " "${BASE_PATH}/.dotfile.managed" > "${BASE_PATH}/.dotfile.managed2"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not add remove file from role [%s]\n" ERROR "${ROLE_PATH}" >&2
                    return 4
                fi
                
                ${DEBUG} && log_it DEBUG CLEANUP "mv '${BASE_PATH}/.dotfile.managed2' '${BASE_PATH}/.dotfile.managed'"
                mv "${BASE_PATH}/.dotfile.managed2" "${BASE_PATH}/.dotfile.managed"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not add file from role [%s]\n" ERROR "${ROLE_PATH}" >&2
                    return 4
                fi
                
            fi
            
            if [[ "${RM_FILE}" == "true" ]]; then
                
                # Remove the link, ready to rebuild
                ${DEBUG} && log_it DEBUG CLEANUP "rm -f '${BASE_PATH}/${SHORT_NAME}'"
                rm -f "${BASE_PATH}/${SHORT_NAME}"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not remove file from role [%s]\n" ERROR "${ROLE_PATH}" >&2
                    return 4
                fi
                
            fi
            
            if [[ "${ADD_ENTRY}" == "true" ]]; then
                
                # Record that we are now managing this file
                ${DEBUG} && log_it DEBUG COPYING "printf '%s %s %s\n' '${SHORT_NAME}' '${ACTUAL_VALUE}' '${name}' >> '${BASE_PATH}/.dotfile.managed'"
                printf "%s %s %s\n" "${SHORT_NAME}" "${ACTUAL_VALUE}" "${name}" >> "${BASE_PATH}/.dotfile.managed"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not add metadata to [%s] to manage file copy from role [%s]\n" ERROR "${BASE_PATH}/${SHORT_NAME}" "${ROLE_PATH}" >&2
                    return 5
                fi
                
            fi
            
            if [[ "${COPY_FILE}" == "true" ]]; then
            
                ${DEBUG} && log_it DEBUG COPYING "cp --recursive --archive '${name}' '${BASE_PATH}/${SHORT_NAME}'"
                cp --recursive --archive "${name}" "${BASE_PATH}/${SHORT_NAME}"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not add file from role [%s]\n" ERROR "${ROLE_PATH}" >&2
                    return 5
                fi
                
            fi
            
        done
        
    fi
    
    return 0
}

function teardown_role_links
{
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    shift 2
    
    USE_ENV=false
    USE_LINK=false
    USE_DEPS=false
    USE_PATHS=false
    USE_FILES=false
    USE_ALIASES=false
    USE_SCRIPT=false
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias  ) shift; USE_ALIASES=true; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                       ;;
            --files  ) shift; USE_FILES=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                       ;;
            --link   ) shift; USE_LINK=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                       ;;
            --env    ) shift; USE_ENV=true;     FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                       ;;
            --deps   ) shift; USE_DEPS=true;    FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                       ;;
            --path   ) shift; USE_PATHS=true;   FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                       ;;
            --script ) shift; USE_SCRIPT=true;  FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                       ;;
            *        ) break
                       ;;
                       
        esac
        
    done
    
    [[ "$USE_LINK" == "false" ]] && return 0

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_LINK="$ROLE_PATH/links"
    
    # First step is to create links if configured and the role contains them
    if [[ -d "${ROLE_LINK}" ]]; then
    
        # Look at direct children
        TARGETS=$(find "$ROLE_LINK" -maxdepth 1 -mindepth 1 2>/dev/null | reverse_lines)
        
        # Go through all the files/folders found in the links folder as we need to point to them as symbolic
        # links in the users home directory
        for name in ${TARGETS}; do
        
            SHORT_NAME=$(basename "${name}")
            SHORT_NAME_SAFE=$(escape_regex "${SHORT_NAME}")

            BASE_PATH="${HOME}"
            LINKS_LIST=""
            
            # Check if there is a role configuration file redirecting this link
            [[ -f "$ROLE_PATH/meta" ]] && LINKS_LIST=$(grep -v "^link ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3)
            [[ -n "${LINKS_LIST}" ]] && BASE_PATH="${LINKS_LIST}"
            
            # Check if link already exists, if so, remove it
            if [[ -L "${BASE_PATH}/${SHORT_NAME}" ]]; then

                "${DEBUG}" && log_it DEBUG CLEANUP "rm -f '${BASE_PATH}/${SHORT_NAME}'"
                rm -f "${BASE_PATH}/${SHORT_NAME}"
                if [[ $? -ne 0 ]]; then
                    printf "%s: Could not add reset symbolic links from role [%s]\n" ERROR "${ROLE_PATH}" >&2
                    return 4
                fi

            fi
            
        done
        
    fi
    
    return 0
}


#-- Includes -------------------------------------------------------------------------------------------------------

# Default to current directory if environment not set
if [[ -z "$DOTFILES_HOME" ]]; then
    DOTFILES_HOME="$PWD"
fi

# Give the user a chance to define env variables then take system defaults
if [[ -n "${DOTFILES_CONFIG}" ]]
then
    if [[ -f "${DOTFILES_CONFIG}" ]]; then
        . "${DOTFILES_CONFIG}"
        if [[ $? -ne 0 ]]
        then
            printf "%s: Could not source '%s'.  This is defined in the environment variable %s.  Exiting\n" ERROR "$DOTFILES_CONFIG" DOTFILES_CONFIG >&2
            return 1
        fi
    else
        printf "%s: Could not source '%s'.  This is defined in the environment variable %s but does not exist.  Exiting\n" ERROR "$DOTFILES_CONFIG" DOTFILES_CONFIG >&2
        return 1
    fi
fi

# Check if user has this in their home directory
if [[ -f "$HOME/.dotfiles.cfg" ]]
then
    . "$HOME/.dotfiles.cfg"
    if [[ $? -ne 0 ]]
    then
        printf "%s: Could not source '%s'.  Exiting\n" ERROR "$HOME/.dotfiles.cfg" >&2
        return 1
    fi
fi

if [[ -f "$DOTFILES_HOME/etc/dotfiles.cfg" ]]
then
    . "$DOTFILES_HOME/etc/dotfiles.cfg"
    if [[ $? -ne 0 ]]
    then
        printf "%s: Could not source '%s'.  Exiting\n" ERROR "${DOTFILES_HOME}/etc/dotfiles.cfg" >&2
        return 1
    fi
fi

if [[ -f "$DOTFILES_ADMIN_CONFIG" ]]
then
    . "$DOTFILES_ADMIN_CONFIG"
    if [[ $? -ne 0 ]]
    then
        printf "%s: Could not source '%s'.  Exiting\n" ERROR "${DOTFILES_ADMIN_CONFIG}" >&2
        return 1
    fi
fi


#-- Logging ---------------------------------------------------------------------------------------------------------

# Give a sane default if not defined
if [[ -z "$DOTFILES_LOG" ]]; then
    DOTFILES_LOG="$DOTFILES_HOME/log"
fi

# Check if the log is writeable
if [[ ! -r "$DOTFILES_LOG" ]]; then
    printf "%s: The value of %s [%s] is not readable.  Exiting\n" ERROR DOTFILES_LOG "$DOTFILES_LOG" >&2
    return $ERR_INVALID_LOG_PATH
fi

# Check if the log is writeable
if [[ ! -w "$DOTFILES_LOG" ]]; then
    printf "%s: The value of %s [%s] is not writeable.  Exiting\n" ERROR DOTFILES_LOG "$DOTFILES_LOG" >&2
    return $ERR_INVALID_LOG_PATH
fi

log_it INFO PARAMS "dotfile $@"
if [[ $? -ne 0 ]]; then
    printf "%s: Could not write to %s [%s] is not a valid file.  Exiting\n" ERROR DOTFILES_LOG "$DOTFILES_LOG" >&2
    return $ERR_INVALID_LOG_PATH
fi


#-- Main -----------------------------------------------------------------------------------------------------------

USE_DEPS="${DOTFILES_INCLUDE_DEPENDENCIES:-true}"   # Do we include role dependencies
USE_ENV="${DOTFILES_INCLUDE_ENV:-true}"             # Do we include role environments
USE_LINK="${DOTFILES_INCLUDE_LINKS:-true}"          # Do we built symbolic links if required
USE_PATHS="${DOTFILES_INCLUDE_PATHS:-true}"         # Do we build paths if required
USE_FILES="${DOTFILES_INCLUDE_FILES:-true}"         # Do we copy files if required
USE_ALIASES="${DOTFILES_INCLUDE_ALIASES:-true}"     # Do we instantiate aliases
USE_SCRIPT="${DOTFILES_INCLUDE_SCRIPT:-true}"       # Do we include role environments / scripts

DEBUG="${DOTFILES_DEBUG:-false}"                    # Debug messages to log output
TRACE=false                                         # Trace is purely at a user level

HASTTY=true
tty -s
[[ $? -ne 0 ]] && HASTTY=false                      # Helper variable to determine whether we have an interactive user


while [[ $# -ne 0 ]]; do

    case "$1" in

        -A | --no-aliases      ) USE_ALIASES=false
                                 shift
                                 ;;
        
        -F | --no-files        ) USE_FILES=false
                                 shift
                                 ;;
        
        -K | --no-link         ) USE_LINK=false
                                 shift
                                 ;;

        -N | --no-env          ) USE_ENV=false
                                 shift
                                 ;;

        -D | --no-dependencies ) USE_DEPS=false
                                 shift
                                 ;;
        
        -P | --no-paths        ) USE_PATHS=false
                                 shift
                                 ;;
        
        -S | --no-script       ) USE_SCRIPT=false
                                 shift
                                 ;;
        
        -x | --debug           ) DEBUG=true
                                 shift
                                 ;;

        -X | --trace           ) DEBUG=true
                                 TRACE=true
                                 shift
                                 set -xv
                                 ;;

        -h | --help            ) usage
                                 return $SUCCESS
                                 ;;
                                 
        *                      ) break
                                 ;;

    esac

done


FUNC_SWITCHES=""
[[ "$USE_ALIASES" == "true" ]] && FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
[[ "$USE_FILES"   == "true" ]] && FUNC_SWITCHES="${FUNC_SWITCHES} --files"
[[ "$USE_LINK"    == "true" ]] && FUNC_SWITCHES="${FUNC_SWITCHES} --link"
[[ "$USE_ENV"     == "true" ]] && FUNC_SWITCHES="${FUNC_SWITCHES} --env"
[[ "$USE_DEPS"    == "true" ]] && FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
[[ "$USE_PATHS"   == "true" ]] && FUNC_SWITCHES="${FUNC_SWITCHES} --path"
[[ "$USE_SCRIPT"  == "true" ]] && FUNC_SWITCHES="${FUNC_SWITCHES} --script"

# Check we have the right amount of parameters left
if [[ $# -lt 2 ]]; then
    if [[ $# -lt 1 || ( "$1" != "list" && "$1" != "reset" ) ]]; then
        usage >&2
        return $ERR_UNKNOWN_CMD
    fi
fi

MAIN_CMD="$1"
shift

# Basic validation and executing high level commands that dont require environment manipulation
case "$MAIN_CMD" in

    request            ) ;;
    release            ) ;;
    reset              ) ;;
    describe           ) ;;
    list               ) ;;
    help               ) ;;
    -h | --help        ) usage
                         return $SUCCESS
                         ;;
    *                  ) usage >&2
                         return $ERR_UNKNOWN_CMD
                         ;;

esac

# Find all roles installed on the machine / in known paths
ROLE_LIST=$( list_roles "${DOTFILES_ROLES_PATH}" )

# Very lightweight functionality that doesnt need to know of current role state etc
if [[ "$MAIN_CMD" == "list" ]]; then
    printf "%s\n" "${ROLE_LIST}"
    return $SUCCESS
fi

# Further commands interact directly with an already allocated role or a specific one that needs querying, reset is an exception as it has no arguments
# however due to its implementation We call it like any other
NEW_ROLE=$(        printf "%s\n" "$2" | cut -d":" -f1)
NEW_ROLE_ACTION=$( printf "%s\n" "$2" | cut -d":" -f2)
[[ "$MAIN_CMD" != "reset" ]] && shift


case "$MAIN_CMD" in

    describe           ) describe_role "$NEW_ROLE" "$NEW_ROLE_ACTION" "$ROLE_LIST" ${FUNC_SWITCHES}
                         return $?
                         ;;
    help               ) help_role "$NEW_ROLE"
                         return $?
                         ;;
    
esac


# We perform this seperately than the above so that we arent modifying environment variables simply because we've been asked to describe something
export DOTFILES_ALLOCATION_INDEX="${DOTFILES_ALLOCATION_INDEX:-0}"

# Basic validation
case "$MAIN_CMD" in

    request            ) request_role  "$NEW_ROLE" "$NEW_ROLE_ACTION" "$ROLE_LIST" ${FUNC_SWITCHES}
                         ;;
    release            ) release_role  "$NEW_ROLE" "$NEW_ROLE_ACTION" "$ROLE_LIST" ${FUNC_SWITCHES}
                         ;;
    reset              ) release_role  "@"         "$NEW_ROLE_ACTION" "$ROLE_LIST" ${FUNC_SWITCHES}
                         ;;
    
esac

# Remove if becomes unnecessary
[[ "${DOTFILES_ALLOCATION_INDEX}" -le 0 ]] && unset DOTFILES_ALLOCATION_INDEX

return $SUCCESS
