#!/bin/sh
#####################################################################################################################
#
# Name:          dotfile
# Developer:     Philip Bowditch
# Created:       20151110
# Description:   Encourages the version control, documentation and sharing of *NIX dot files.  Provides a highly
#                configurable user environment where those core files / settings can be seperated out into roles
#                and called / released at will, providing a clean setup.  
#
#####################################################################################################################


#-- Constants -------------------------------------------------------------------------------------------------------

ERR_UNKNOWN_CMD=1
ERR_INVALID_LOG_PATH=2
ERR_ROLE_NOT_FOUND=3
ERR_FAILED_LOADING_CONFIG=4

ERR_AUTHENTICATION_FAILED=10
ERR_AUTHORIZATION_FAILED=20

ERR_CREATE_ALIAS_FAILED=50
ERR_CREATE_DEPENDENCY_FAILED=51
ERR_CREATE_SCRIPT_FAILED=52
ERR_CREATE_ENV_FAILED=53
ERR_CREATE_LINK_FAILED=54

ERR_DELETE_ALIAS_FAILED=80
ERR_DELETE_DEPENDENCY_FAILED=81
ERR_DELETE_ENV_FAILED=83

SUCCESS=0


#-- Functions -------------------------------------------------------------------------------------------------------

function usage
{
    ####################################################################################
    #
    # Description:  Print high level usage for this script
    # 
    ####################################################################################

    cat <<EOF
usage: dotfile <command> <options>

Where <command> is one of the following:

    request           - Applys a role    
    release           - Releases/removes a role
    reset             - Removes all roles
    describe          - Output basic information about a role
    list              - Prints out all supported roles
    help              - Prints out help for a given <command>
    
Where 

Where <options> consist of 1 or more of the following:

    ( -A | --no-aliases      )                  - Do not include role aliase definitions
    ( -N | --no-env          )                  - Do not inherit environment variables from the role
    ( -F | --no-files        )                  - Do not initialise files copies from roles
    ( -K | --no-link         )                  - Do not initialise symbolic links
    ( -D | --no-dependencies )                  - Do not include dependencies from other roles/products
    ( -P | --no-paths        )                  - Do not include role directories to PATH and LD_LIBRARY_PATH environment variables
    ( -S | --no-script       )                  - Do not execute role scripts
    ( -T | --no-templates    )                  - Do not evaluate templates
    ( -x | --debug           )                  - Force debugging extra info to the log file
    ( -X | --trace           )                  - Force command tracing along with debug information
    ( -h | --help            )                  - Prints out this usage message

NOTE: The order of command line options is important and will be processed left to right.  Therefore any global options
that will affect how you want the command to work should be specified as early as possible e.g. --debug or --catalog.  

Examples

To allocate an etl developer role you would source this script in your .profile as follows

    . dotfile request etl

To deactivate a role you must release them in the reverse order they were applied

    . dotfile release ddl_developer && . dotfile release etl
    
Note although the chaining of roles is quite valid we would suggest instead creating a custom role where
the 2 or more roles you wish to allocate are specified as dependencies.  Not only does this make the 
command easier to manage and remember but will also allocate / deallocate in a consistent manner.  
    
As a handy shortcut the following will release all roles appropriately

    . dotfile release @
    
or

    . dotfile reset

EOF
}

function log_it
{
    ####################################################################################
    #
    # Description:  Logs a message to a file
    # Parameters:   1 - The severity of the message, e.g. INFO, WARN, DEBUG, ERROR
    #               2 - The category identifier for this log message
    #               * - The message
    # Requires:     USER         - The login name of the current user
    #               DOTFILES_LOG - The path to a log file to write to
    #               3 - Used for identification the pid of the process being run
    # 
    ####################################################################################

    LEVEL="$1"
    CATEGORY="$2"
    shift 2

    [[ -n "$DOTFILES_LOG" ]] && printf "%s: %s: %s: %s: %s\n" "$(date +%Y%m%d%H%M%S)" "${USER}" $$ "${CATEGORY}" "$@" >> "$DOTFILES_LOG"
}

function print_error
{
    ####################################################################################
    #
    # Description:  Utility function to print out an error message in a common format
    # Parameters:   1 - The printf pattern to output
    #               * - The tokens to pass in
    # 
    ####################################################################################
    
    EXITCODE=""
    if [[ "${1}" == "--exit" ]]; then
        EXITCODE="${2}"
        shift 2
    fi
    
    MSG="$1"
    shift
    
    printf "%s: ${MSG}\n" ERROR "$@" >&2
    [[ -n "${EXITCODE}" ]] && exit $EXITCODE
}

function print_status
{
    get_env | grep "^DOTFILES_ADD_ROLE__"
    echo "%%%%%"
    APPLIED_ROLE=($(get_env | grep "^DOTFILES_ADD_ROLE__" | cut -d"_" -f5- | unnormalize_role | sed 's/=/ /g' | sort -k2,2 -nr | sed 's/ /,/g' ))

    for ROLE_FOUND in ${APPLIED_ROLE[@]}; do
        ROLE_NAME=$(printf "%s\n" "$ROLE_FOUND" | cut -d, -f1)
        printf "%s\n" "$ROLE_NAME"
    done

    return $SUCCESS
}

function get_env
{
    env
}

function read_config
{
    ####################################################################################
    #
    # Description:  Outputs the contents of a config file, this will strip out blank
    #               linse and comments
    # Parameters:   The config file to read
    # 
    ####################################################################################

    grep -v "^#" "$1" | grep -v "^\$"
}

function reverse_lines
{
    ####################################################################################
    #
    # Description:  Reverses the lines on stdin
    # Parameters:   None
    # 
    ####################################################################################
    
    # tac is not cross platform, awk is more likely to be
    #tac
    awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }'
}

function reverse_words
{
    ####################################################################################
    #
    # Description:  Reverses the words on a single line of input 
    # Parameters:   None
    # 
    ####################################################################################
    
    awk '{for(i=NF;i>0;--i)printf "%s%s",$i,(i>1?OFS:ORS)}'
}

function normalize_role
{
    ####################################################################################
    #
    # Description:  Converts afile system role name into an environment parameter based
    #               role name (file system names can contain a signficantly wider
    #               set of characters.  
    # Parameters:   1 - Optional. The role name to normalize, uses stdin if not set
    # 
    ####################################################################################
    
    if [[ $# -gt 0 ]]; then
        printf "%s\n" "$1" | tr '[a-z]' '[A-Z]' | sed 's/[.]/__DOT__/g' | sed 's/[-]/__DASH__/g' | sed 's/[ ]/__SPACE__/g'
    else
        tr '[a-z]' '[A-Z]' | sed 's/[.]/__DOT__/g' | sed 's/[-]/__DASH__/g' | sed 's/[ ]/__SPACE__/g'
    fi
}

function unnormalize_role
{
    ####################################################################################
    #
    # Description:  Converts an environment parameter role name back to a filesystem 
    #               based role name (file system names can contain a signficantly wider
    #               set of characters.  
    # Parameters:   1 - Optional. The role name to unnormalize, uses stdin if not set
    # 
    ####################################################################################
    
    if [[ $# -gt 0 ]]; then
        printf "%s\n" "$1" | sed 's/__SPACE__/ /g' | sed 's/__DASH__/-/g' | sed 's/__DOT__/./g' | tr '[A-Z]' '[a-z]'
    else
        sed 's/__SPACE__/ /g' | sed 's/__DASH__/-/g' | sed 's/__DOT__/./g' | tr '[A-Z]' '[a-z]'
    fi
}

function escape_regex
{
    ####################################################################################
    #
    # Description:  Escapes some commonly used characters used within simple regular
    #               expression matching (i.e. grep).  This is so user entered values
    #               cannot subvert a matching attempt
    # Parameters:   1 - The value to escape
    # 
    ####################################################################################
    
    if [[ $# -gt 0 ]]; then
        printf "%s\n" "$1" | sed 's/[[\.*^$/]/\\&/g'
    else
        sed 's/[[\.*^$/]/\\&/g'
    fi
}

function escape_regex_extended
{
    ####################################################################################
    #
    # Description:  Escapes some commonly used characters used within extended regular
    #               expression matching (i.e. perl or egrep).  This is so user entered
    #               values cannot subvert a matching attempt
    # Parameters:   1 - The value to escape
    # 
    ####################################################################################
    
    if [[ $# -gt 0 ]]; then
        printf "%s\n" "$1" | sed 's/[[\.*^$(){}?+|/]/\\&/g'
    else
        sed 's/[[\.*^$/]/\\&/g'
    fi
}

function get_role_path
{
    ####################################################################################
    #
    # Description:  Given a role name, returns its full path (if any)
    # Parameters:   1 - The name of the role to check for
    #               2 - The system delimited path to check
    # 
    ####################################################################################
    
    NEW_ROLE="$1"
    ROLE_LIST="$2"

    printf "%s\n" "${ROLE_LIST}" | grep -i ".*/${NEW_ROLE}$" | head -1
}

function list_roles
{
    ####################################################################################
    #
    # Description:  Returns all roles found on the path
    # Parameters:   1 - The system delimited path-like variable to check against
    # 
    ####################################################################################
    
    ROLES_PATH="$1"

    # Find all roles installed on the machine / in known paths
    printf "%s\n" "${ROLES_PATH}" | sed 's/:/\n/g' | xargs -i find {} -maxdepth 1 -mindepth 1 2>/dev/null
}

function authenticate
{
    ####################################################################################
    #
    # Description:  Authenticates a user (TODO)
    # Parameters:   1 - The user name
    # 
    ####################################################################################
    
    return $SUCCESS
}

function validate_role
{
    ####################################################################################
    #
    # Description:  Validates a role exists and the user is allowed access
    # Parameters:   1 - The role name to validate
    #               2 - The complete list of roles to validate against
    # 
    ####################################################################################

    NEW_ROLE="$1"
    ROLE_LIST="$2"

    ROLE_FOUND=$(get_role_path "${NEW_ROLE}" "$ROLE_LIST" )

    if [[ -z "${ROLE_FOUND}" ]]; then
        print_error "Role [%s] is unrecognised, use %s to print out supported roles" "$NEW_ROLE" "$DOTFILES_HOME/bin/dotfile list"
        return $ERR_ROLE_NOT_FOUND
    fi

    "${DOTFILES_AUTHENTICATE_PATH:-true}" "$USER"
    if [[ $? -ne 0 ]]; then
        log_it ERROR REQUEST "$NEW_ROLE"
        print_error "Could not authenticate user [%s].  Exiting" "$USER"
        return $ERR_AUTHENTICATION_FAILED
    fi

    "${DOTFILES_AUTHORIZE_PATH:-true}" "$USER" "$NEW_ROLE"
    if [[ $? -ne 0 ]]; then
        log_it ERROR REQUEST "$NEW_ROLE"
        print_error "User [%s] is not granted access to role [%s].  Exiting" "$USER" "$NEW_ROLE"
        return $ERR_AUTHORIZATION_FAILED
    fi

    return $SUCCESS
}

function help_role
{
    NEW_CMD="$1"

    NEW_CMD_UPPER=$(printf "%s\n" "$NEW_CMD" | tr '[a-z]' '[A-Z]')
    
    case "$NEW_CMD_UPPER" in
    
        REQUEST  ) printf "%s\n" "Adds a role to the users account"
                   ;;
        RELEASE  ) printf "%s\n" "Removes a role from the users account"
                   ;;
        RESET    ) printf "%s\n" "Removes all roles from the users account"
                   ;;
        DESCRIBE ) printf "%s\n" "Outputs summary information regarding a role"
                   ;;
        LIST     ) printf "%s\n" "Outputs what roles are available"
                   ;;
        STATUS   ) printf "%s\n" "Outputs what roles are currently applied"
                   ;;
        HELP     ) usage
                   ;;
        *       )  usage >&2
                   return $ERR_UNKNOWN_CMD
                   ;;

    esac

    return $SUCCESS
}

function describe_role
{
    # Describe A Role ######
    NEW_ROLE="$1"
    NEW_ROLE_ACTION="$2"
    ROLE_LIST="$3"
    
    shift 3
    
    FUNC_SWITCHES=""
    
    while [[ $# -gt 0 ]]; do
    
        case "$1" in
        
            --alias     ) shift; FUNC_SWITCHES="${FUNC_SWITCHES} --alias"
                          ;;
            --files     ) shift; FUNC_SWITCHES="${FUNC_SWITCHES} --files"
                          ;;
            --link      ) shift; FUNC_SWITCHES="${FUNC_SWITCHES} --link"
                          ;;
            --env       ) shift; FUNC_SWITCHES="${FUNC_SWITCHES} --env"
                          ;;
            --deps      ) shift; FUNC_SWITCHES="${FUNC_SWITCHES} --deps"
                          ;;
            --path      ) shift; FUNC_SWITCHES="${FUNC_SWITCHES} --path"
                          ;;
            --script    ) shift; FUNC_SWITCHES="${FUNC_SWITCHES} --script"
                          ;;
            --templates ) shift; FUNC_SWITCHES="${FUNC_SWITCHES} --templates"
                          ;;
            *           ) break
                          ;;
                       
        esac
        
    done

    # Normalize for easier pattern matching etc
    NEW_ROLE_UPPER=$(normalize_role "${NEW_ROLE}")
    
    validate_role "${NEW_ROLE}" "$ROLE_LIST" || return $?

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_MAIN="$ROLE_PATH"
        
    # A role can be a script, however typically its a directory
    # defined with an entrypoint of main
    [[ -d "${ROLE_PATH}" ]] && ROLE_MAIN="${ROLE_PATH}/main"

    for SWITCH in ${FUNC_SWITCHES}; do
    
        case "$SWITCH" in
        
            --alias     ) ;;
            --files     ) ;;
            --link      ) ;;
            --env       ) ;;
            --deps      ) cat "${ROLE_PATH}/dependencies"
                          if [[ $? -ne 0 ]]; then
                              print_error "Could not output role [%s]" "${ROLE_PATH}"
                              return 4
                          fi
                          ;;
            --path      ) ;;
            --script    ) ;;
            --templates ) ;;

        esac
    
    done
}

function release_role
{
    NEW_ROLE="$1"
    NEW_ROLE_ACTION="$2"
    ROLE_LIST="$3"
    
    shift 3
    
    # Normalize for easier pattern matching etc
    NEW_ROLE_UPPER=$(normalize_role "${NEW_ROLE}")
    
    # Check for shortcut of releasing all
    if [[ "${NEW_ROLE}" == "@" ]]; then
    
        # set -A APPLIED_ROLE $(env) etc is non posix compliant
        
        # get all applied roles and sort into applied order
        APPLIED_ROLE=($(get_env | grep "^DOTFILES_ADD_ROLE__" | cut -d"_" -f5- | unnormalize_role | sed 's/=/ /g' | sort -k2,2 -nr))
        #echo "1: #: ${#APPLIED_ROLE[@]}: 0: ${APPLIED_ROLE[0]}: NEW_ROLE: ${NEW_ROLE}"
        
        while [[ "${#APPLIED_ROLE[@]}" -gt 0 ]]; do

            # release the last applied role
            release_role "${APPLIED_ROLE[0]}" "${NEW_ROLE_ACTION}" "${ROLE_LIST}" "$@" || return $?

            # refresh roles still applied and sort in applied order
            APPLIED_ROLE=($(get_env | grep "^DOTFILES_ADD_ROLE__" | cut -d"_" -f5- | unnormalize_role | sed 's/=/ /g' | sort -k2,2 -nr))

        done
        
        return $SUCCESS
    fi

    validate_role "${NEW_ROLE}" "$ROLE_LIST" || return $?
    
    # Exit if role is not ready to be released (strict ordering is important so its a !=)
    ROLE_INDEX=$(get_env | grep "^DOTFILES_ADD_ROLE__${NEW_ROLE_UPPER}=" | cut -d"=" -f2)
    if [[ "${DOTFILES_ALLOCATION_INDEX}" -ne "${ROLE_INDEX}" ]]; then
        return $SUCCESS
    fi

    # Remove any global identifiers we may have set, including the index
    eval unset DOTFILES_ADD_ROLE__${NEW_ROLE_UPPER}
    export DOTFILES_ALLOCATION_INDEX=$(( DOTFILES_ALLOCATION_INDEX - 1 ))

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_META="$ROLE_PATH/meta"
    EVAL_ORDER="${DOTFILES_EVALUATION_ORDER}"
    
    # See if the author has reset how this role is to be evaluated
    if [[ -f "$ROLE_META" ]]; then
        FOUND_OVERRIDE=$(grep -i "^stage-order " "$ROLE_META" | cut -d" " -f2- | tr '[A-Z]' '[a-z]' )
        [[ -n "$FOUND_OVERRIDE" ]] && EVAL_ORDER="$FOUND_OVERRIDE"
    fi
    
    # Perform stages in reverse order, e.g. if it was A B C D, now its D C B A
    REVERSE_EVALUATION_ORDER=$( printf "%s\n" "${EVAL_ORDER}" | reverse_words )
    for STAGE in ${REVERSE_EVALUATION_ORDER}; do
    
        case "${STAGE}" in
        
            aliases      ) teardown_role_aliases      --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            files        ) teardown_role_files        --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            links        ) teardown_role_links        --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            dependencies ) teardown_role_dependencies --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            env          ) teardown_role_environment  --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            path         ) teardown_role_paths        --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            script       ) teardown_role_script       --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            templates    ) teardown_role_templates    --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            *            ) print_error "Unknown value provided for [%s], the value is [%s]" "${DOTFILES_EVALUATION_ORDER}" "${STAGE}"
                           return 99
                           ;;
            
        esac
        
    done
    
    return $SUCCESS
}

function request_role
{
    NEW_ROLE="$1"
    NEW_ROLE_ACTION="$2"
    ROLE_LIST="$3"
    
    shift 3
    
    # Normalize for easier pattern matching etc
    NEW_ROLE_UPPER=$(normalize_role "${NEW_ROLE}")
    
    # Check user has access to this role
    validate_role "${NEW_ROLE}" "$ROLE_LIST" || return $?
    
    # Exit if role is already defined, we dont request a role already granted
    ROLE_EXISTS=$(get_env | grep "^DOTFILES_ADD_ROLE__${NEW_ROLE_UPPER}=")
    if [[ -n "${ROLE_EXISTS}" ]]; then
        return $SUCCESS
    fi

    
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_META="$ROLE_PATH/meta"
    
    # if we're not forcing a request, check for scope instructions
    if [[ "${FORCE_HIDDEN}" != "true" && -f "$ROLE_META" ]]; then
        PRIVATE=$(grep -i "^scope " "$ROLE_META" | cut -d" " -f2 | tr '[A-Z]' '[a-z]' )

        case "${PRIVATE:-public}" in

            public    ) ;;
            *         ) print_error "Role [%s] is marked private and cannot be requested" "$NEW_ROLE"
                        return 1
                        ;;

        esac

    fi

    # First step is to create links if configured and the role contains them
    # Second step is to inherit any common dependencies if configured and there is a dependencies file
    # last step is to inherit the environment if configured and there is an executable file
    EVAL_ORDER="${DOTFILES_EVALUATION_ORDER}"
    
    # See if the author has reset how this role is to be evaluated
    if [[ -f "$ROLE_META" ]]; then
        FOUND_OVERRIDE=$(grep -i "^stage-order " "$ROLE_META" | cut -d" " -f2- )
        [[ -n "$FOUND_OVERRIDE" ]] && EVAL_ORDER="$FOUND_OVERRIDE"
    fi
    
    EVAL_ORDER=$(printf "%s\n" "${EVAL_ORDER}" | tr '[A-Z]' '[a-z]')

    for STAGE in ${EVAL_ORDER}; do

        case "${STAGE}" in
        
            aliases      ) setup_role_aliases      --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            files        ) setup_role_files        --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            links        ) setup_role_links        --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            dependencies ) setup_role_dependencies --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            env          ) setup_role_environment  --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            path         ) setup_role_paths        --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            script       ) setup_role_script       --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            templates    ) setup_role_templates    --role "${NEW_ROLE}" --list "${ROLE_LIST}" "$@" || return $?
                           ;;
            *            ) print_error "Unknown value provided for [%s], the value is [%s]" "${DOTFILES_EVALUATION_ORDER}" "${STAGE}"
                           return 99
                           ;;
        
        esac

    done
    
    # Increment global variables to indicate the success of this request
    export DOTFILES_ALLOCATION_INDEX=$(( DOTFILES_ALLOCATION_INDEX + 1 ))
    eval export DOTFILES_ADD_ROLE__${NEW_ROLE_UPPER}"="${DOTFILES_ALLOCATION_INDEX}
}

function setup_role_aliases
{
    ####################################################################################
    #
    # Description:  Roles can contain aliases.  Provisio nthem if found
    # 
    ####################################################################################
    
    NEW_ROLE=""
    ROLE_LIST=""

    USE_ALIASES=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role   ) NEW_ROLE="${my_arr[$i]}"
                       ;;
            --list   ) ROLE_LIST="${my_arr[$i]}"
                       ;;
        
            --alias  ) USE_ALIASES="$var"
                       ;;
                       
        esac
        
    done
    
    # Quick exit if no aliases used
    [[ -z "$USE_ALIASES" ]] && return $SUCCESS

    # Find the role in our global roles list, it should be a leaf directory
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_ALIASES="$ROLE_PATH/aliases"
    
    # Second step is to inherit any common dependencies if configured and there is a dependencies file
    [[ ! -f "$ROLE_ALIASES" ]] && return $SUCCESS
    
    
    # Cant use pipes as the while loop becomes a subshell in bash, variables etc are not exposed
    #read_config "$ROLE_ALIASES" | while read -r name value; do
        
    ALIASES=$(read_config "$ROLE_ALIASES" | cut -d" " -f1)
        
    # Go through all alias names, grab their value and create the alias
    for ALIAS_DEF in ${ALIASES}; do
            
        # Escape, suitable for grep
        name=$(printf "%s\n" "$ALIAS_DEF" | sed 's|\.|\\.|g')
        value=$(grep "^$name " "$ROLE_ALIASES" | tail -1 | cut -d" " -f2-)

        eval alias -- "${ALIAS_DEF}"="${value}"
        if [[ $? -ne 0 ]]; then
            print_error "Could not create alias [%s] from role [%s]" "${ALIAS_DEF}" "${ROLE_PATH}"
            return $ERR_CREATE_ALIAS_FAILED
        fi

    done
        
    return $SUCCESS
}

function setup_role_dependencies
{
    ####################################################################################
    #
    # Description:  A role can be dependent on the creation of another role.  Run it
    # 
    ####################################################################################
    
    NEW_ROLE=""
    ROLE_LIST=""
    USE_ENV=""
    USE_LINK=""
    USE_DEPS=""
    USE_PATHS=""
    USE_FILES=""
    USE_ALIASES=""
    USE_SCRIPT=""
    USE_TEMPLATES=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role      ) NEW_ROLE="${my_arr[$i]}"
                          ;;
            --list      ) ROLE_LIST="${my_arr[$i]}"
                          ;;
        
            --alias     ) USE_ALIASES="$var"
                          ;;
            --files     ) USE_FILES="$var"
                          ;;
            --link      ) USE_LINK="$var"
                          ;;
            --env       ) USE_ENV="$var"
                          ;;
            --deps      ) USE_DEPS="$var"
                          ;;
            --path      ) USE_PATHS="$var"
                          ;;
            --script    ) USE_SCRIPT="$var"
                          ;;
            --templates ) USE_TEMPLATES="$var"
                          ;;
                       
        esac
        
    done
    
    # Quick exit if no known dependencies
    [[ -z "$USE_DEPS" ]] && return $SUCCESS

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_DEPS="$ROLE_PATH/dependencies"

    # Second step is to inherit any common dependencies if configured and there is a dependencies file
    [[ ! -f "$ROLE_DEPS" ]] && return $SUCCESS

    
    # Find our dependencies, should be of the format role <dependency>
    DEPS_LIST=$(grep -i "^role " "$ROLE_DEPS" | sed 's/ /,/g')
    
    for DEP_ROLE in ${DEPS_LIST}; do
        ROLE_NAME=$(printf "%s\n" "${DEP_ROLE}" | cut -d, -f2)

        # We could do this outside of the loop but because we source other scripts they might do this also
        # safer to do this on every loop to ensure our variables look ok
        REVERSE_FUNC_SWITCHES=""
        [[ -z "$USE_ENV"       ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-env"
        [[ -z "$USE_LINK"      ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-link"
        [[ -z "$USE_PATHS"     ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-paths"
        [[ -z "$USE_FILES"     ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-files"
        [[ -z "$USE_ALIASES"   ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-aliases"
        [[ -z "$USE_SCRIPT"    ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-script"
        [[ -z "$USE_TEMPLATES" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-templates"
        [[ "$DEBUG" == "true"  ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --debug"
        [[ "$TRACE" == "true"  ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --trace"
            
        # NOTE: We do not add an option for use dependencies, it is assumed otherwise we would not have got this far in the function
        . $DOTFILES_HOME/bin/dotfile --force ${REVERSE_FUNC_SWITCHES} request "${ROLE_NAME}"
        if [[ $? -ne 0 ]]; then
            print_error "Could not add dependency [%s] from role [%s]" "$ROLE_NAME" "$ROLE_PATH"
            return $ERR_CREATE_DEPENDENCY_FAILED
        fi
            
        # Reset input parameters, there is a chance that any script we source can change these values
        # so we reset just to make sure
        NEW_ROLE=""
        ROLE_LIST=""
        USE_ENV=""
        USE_LINK=""
        USE_DEPS=""
        USE_PATHS=""
        USE_FILES=""
        USE_ALIASES=""
        USE_SCRIPT=""
        USE_TEMPLATES=""
    
        i=0
        my_arr=("$@")
        for var in "$@"; do
    
            i=$(( i + 1 ))
        
            case "$var" in
        
                --role      ) NEW_ROLE="${my_arr[$i]}"
                              ;;
                --list      ) ROLE_LIST="${my_arr[$i]}"
                              ;;
        
                --alias     ) USE_ALIASES="$var"
                              ;;
                --files     ) USE_FILES="$var"
                              ;;
                --link      ) USE_LINK="$var"
                              ;;
                --env       ) USE_ENV="$var"
                              ;;
                --deps      ) USE_DEPS="$var"
                              ;;
                --path      ) USE_PATHS="$var"
                              ;;
                --script    ) USE_SCRIPT="$var"
                              ;;
                --templates ) USE_TEMPLATES="$var"
                              ;;
                       
            esac
        
        done
            
        NEW_ROLE_UPPER=$(printf "%s\n" "${NEW_ROLE}" | normalize_role)
            
        ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
        ROLE_MAIN="$ROLE_PATH"
        ROLE_LINK="${ROLE_PATH}/links"
        ROLE_DEPS="${ROLE_PATH}/dependencies"
        [[ -d "${ROLE_PATH}" ]] && ROLE_MAIN="${ROLE_PATH}/main"
            
    done
    
    return $SUCCESS
}

function setup_role_environment
{
    NEW_ROLE=""
    ROLE_LIST=""
    
    USE_ENV=""

    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role   ) NEW_ROLE="${my_arr[$i]}"
                       ;;
            --list   ) ROLE_LIST="${my_arr[$i]}"
                       ;;
        
            --env    ) USE_ENV="$var"
                       ;;
                       
        esac
        
    done
    
    [[ -z "$USE_ENV" ]] && return $SUCCESS

    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_ENV="$ROLE_PATH/env"
    
    # last step is to inherit the environment if configured and there is an executable file
    [[ ! -f "$ROLE_ENV" ]] && return $SUCCESS


    # Need to remove the need for a while loop as this spawns a subshell in POSIX / bash so the exports arent exposed
    #read_config "$ROLE_ENV" | while read -r action name value; do
    
    # Format of the env variable file is (set|prepend|append) <name> <value>
    LINES=$(grep -iE "^(set|prepend|append) " "$ROLE_ENV")
    PARAMS=$(printf "%s\n" "$LINES" | cut -d" " -f2)
    
    i=0
    for PARAM in ${PARAMS}; do
        
        i=$(( i + 1 ))
        
        # Escape for egrep
        PARAM_SAFE=$(escape_regex_extended "$PARAM")
        
        # Extract the exact line
        name="$PARAM"
        line=$(printf "%s\n" "$LINES" | head -${i} | tail -1)
        action=$( printf "%s\n" "$line" | cut -d" " -f1  | tr '[A-Z]' '[a-z]' )
        value=$(  printf "%s\n" "$line" | cut -d" " -f3- )

        case "$action" in
            
            set     ) eval export "${name}"="${value}"
                      if [[ $? -ne 0 ]]; then
                          print_error "Could not create environment variable [%s] from role [%s]" "${name}" "${ROLE_PATH}"
                          return $ERR_CREATE_ENV_FAILED
                      fi
                      ;;
            prepend ) eval export "${name}"="${value}:\$${name}"
                      if [[ $? -ne 0 ]]; then
                          print_error "Could not prepend environment variable [%s] from role [%s]" "${name}" "${ROLE_PATH}"
                          return $ERR_CREATE_ENV_FAILED
                      fi
                      ;;
            append  ) eval export "${name}"="\$${name}:${value}"
                      if [[ $? -ne 0 ]]; then
                          print_error "Could not append environment variable [%s] from role [%s]" "${name}" "${ROLE_PATH}"
                          return $ERR_CREATE_ENV_FAILED
                      fi
                      ;;
            
        esac

    done

    return $SUCCESS
}

function setup_role_script
{
    NEW_ROLE=""
    ROLE_LIST=""
    USE_ENV=""
    USE_LINK=""
    USE_DEPS=""
    USE_PATHS=""
    USE_FILES=""
    USE_ALIASES=""
    USE_SCRIPT=""
    USE_TEMPLATES=""

    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role      ) NEW_ROLE="${my_arr[$i]}"
                          ;;
            --list      ) ROLE_LIST="${my_arr[$i]}"
                          ;;
        
            --alias     ) USE_ALIASES="$var"
                          ;;
            --files     ) USE_FILES="$var"
                          ;;
            --link      ) USE_LINK="$var"
                          ;;
            --env       ) USE_ENV="$var"
                          ;;
            --deps      ) USE_DEPS="$var"
                          ;;
            --path      ) USE_PATHS="$var"
                          ;;
            --script    ) USE_SCRIPT="$var"
                          ;;
            --templates ) USE_TEMPLATES="$var"
                          ;;
                       
        esac
        
    done

    [[ -z "$USE_SCRIPT" ]] && return $SUCCESS

    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_MAIN="$ROLE_PATH"
    
    # Incase the base path is a directory then we assume there might be a main file/script
    [[ -d "${ROLE_PATH}" ]] && ROLE_MAIN="${ROLE_PATH}/main"

    
    # last step is to inherit the environment if configured and there is an executable file
    [[ ! -f "$ROLE_MAIN" ]] && return $SUCCESS


    ${DEBUG} && log_it DEBUG CALL ". ${ROLE_MAIN} --setup ${USE_ALIASES} ${USE_FILES} ${USE_LINK} ${USE_ENV} ${USE_DEPS} ${USE_PATHS} ${USE_SCRIPT} ${USE_TEMPLATES}"
    . "${ROLE_MAIN}" --setup ${USE_ALIASES} ${USE_FILES} ${USE_LINK} ${USE_ENV} ${USE_DEPS} ${USE_PATHS} ${USE_SCRIPT} ${USE_TEMPLATES}

    if [[ $? -ne 0 ]]; then
        print_error "Could not run script from role [%s]" "${ROLE_PATH}"
        return $ERR_CREATE_SCRIPT_FAILED
    fi

    return $SUCCESS
}

function setup_role_paths
{
    NEW_ROLE=""
    ROLE_LIST=""

    USE_PATHS=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role   ) NEW_ROLE="${my_arr[$i]}"
                       ;;
            --list   ) ROLE_LIST="${my_arr[$i]}"
                       ;;
        
            --path   ) USE_PATHS="$var"
                       ;;
                       
        esac
        
    done

    # Add directories to their relevent paths if found
    [[ -z "$USE_PATHS" ]] && return $SUCCESS
    
    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_BIN="$ROLE_PATH/bin"
    ROLE_LIB="$ROLE_PATH/lib"
    ROLE_FUN="$ROLE_PATH/funcs"

    DIRECTION_BIN=""
    DIRECTION_LIB=""
    DIRECTION_FUN=""

    if [[ -f "$ROLE_PATH/meta" ]]; then

        DIRECTION_BIN=$(grep -i "^path-method bin (append|prepend|none)\$" "$ROLE_PATH/meta"   | cut -d" " -f2 | tr '[A-Z]' '[a-z]')
        DIRECTION_LIB=$(grep -i "^path-method lib (append|prepend|none)\$" "$ROLE_PATH/meta"   | cut -d" " -f2 | tr '[A-Z]' '[a-z]')
        DIRECTION_FUN=$(grep -i "^path-method funcs (append|prepend|none)\$" "$ROLE_PATH/meta" | cut -d" " -f2 | tr '[A-Z]' '[a-z]')

    fi

    # BIN
    case "${DIRECTION_BIN:-prepend}" in

        prepend ) [[ -d "$ROLE_BIN" ]] && export PATH="$ROLE_BIN:$PATH"
                  ;;
        append  ) [[ -d "$ROLE_BIN" ]] && export PATH="$PATH:$ROLE_BIN"
                  ;;
        none    ) ;;
        *       ) return 65
                  ;;

    esac

    # FPATH
    case "${DIRECTION_FUN:-prepend}" in

        prepend ) [[ -d "$ROLE_FUN" ]] && export FPATH="$ROLE_FUN:$FPATH"
                  ;;
        append  ) [[ -d "$ROLE_FUN" ]] && export FPATH="$FPATH:$ROLE_FUN"
                  ;;
        none    ) ;;
        *       ) return 65
                  ;;

    esac

    # LD_LIBRARY_PATH
    case "${DIRECTION_LIB:-prepend}" in

        prepend ) [[ -d "$ROLE_LIB" ]] && export LD_LIBRARY_PATH="$ROLE_LIB:$LD_LIBRARY_PATH"
                  ;;
        append  ) [[ -d "$ROLE_LIB" ]] && export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$ROLE_LIB"
                  ;;
        none    ) ;;
        *       ) return 65
                  ;;

    esac
    
    return $SUCCESS
}

function setup_role_files
{
    NEW_ROLE=""
    ROLE_LIST=""
    USE_FILES=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role   ) NEW_ROLE="${my_arr[$i]}"
                       ;;
            --list   ) ROLE_LIST="${my_arr[$i]}"
                       ;;
        
            --files  ) USE_FILES="$var"
                       ;;
                       
        esac
        
    done
    
    [[ -z "$USE_FILES" ]] && return $SUCCESS
    
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_FILE="$ROLE_PATH/files"
    
    # First step is to create links if configured and the role contains them
    [[ ! -d "${ROLE_FILE}" ]] && return $SUCCESS
    
    
    # Find direct children
    TARGETS=$(find "$ROLE_FILE" -maxdepth 1 -mindepth 1 2>/dev/null)
        
    # Go through all the files/folders found in the links folder as we need to point to them as symbolic
    # links in the users home directory
    for name in ${TARGETS}; do
        
        SHORT_NAME=$(basename "${name}")
        SHORT_NAME_SAFE=$(escape_regex "${SHORT_NAME}")
            
        BASE_PATH=$(echo ~)
            
        FILES_LIST=""
        [[ -f "$ROLE_PATH/meta" ]] && FILES_LIST=$(grep -v "^[fF][iI][lL][eE] ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3)
        [[ -n "${FILES_LIST}" ]] && BASE_PATH="${FILES_LIST}"
            
        FILES_MANAGED=$(grep -v "^${SHORT_NAME_SAFE} " "${BASE_PATH}/.dotfile.managed")
        ACTUAL_VALUE="-"
            
        # Determines whether we need to copy the file (ie we dont copy a file if it already exists)
        FILE_EXISTS=false
        IS_MANAGED=false
        FILE_MATCHES=false
        META_MATCHES=false
            
        [[ -f "${BASE_PATH}/${SHORT_NAME}" ]] && FILE_EXISTS=true
        [[ -n "${FILES_MANAGED}" ]] && IS_MANAGED=true
            
        # If we appear to have a copy of the file already we check the contents if we can
        if ${FILE_EXISTS}; then

            CKSUM_METHOD=""
            CKSUM_VALUE=""
            if [[ -f "$ROLE_PATH/meta" ]]; then
                CKSUM_METHOD=$(grep -v "^[hH][aA][sS][hH] ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3 | tr '[A-Z]' '[a-z]')
                CKSUM_VALUE=$( grep -v "^[hH][aA][sS][hH] ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f4-)
            fi
                
            case "${CKSUM_METHOD:-skip}" in
                
                sha1sum   ) ACTUAL_VALUE=$(sha1sum   "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                sha224sum ) ACTUAL_VALUE=$(sha224sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                sha256sum ) ACTUAL_VALUE=$(sha256sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                sha384sum ) ACTUAL_VALUE=$(sha384sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                sha512sum ) ACTUAL_VALUE=$(sha512sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                md5sum    ) ACTUAL_VALUE=$(md5sum    "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                force     ) ACTUAL_VALUE="force"
                            ;;
                skip      ) ACTUAL_VALUE="skip"
                            ;;
                
            esac
                
            COMPARE_RESULT=1
                
            if [[ "$ACTUAL_VALUE" == "force" ]]; then
                COMPARE_RESULT=1
            elif [[ "$ACTUAL_VALUE" == "skip" ]]; then
                COMPARE_RESULT=0
            elif [[ -z "${ACTUAL_VALUE}" || "${ACTUAL_VALUE}" == "-" ]]; then 
                cmp "${BASE_PATH}/${SHORT_NAME}" "${name}" 2>/dev/null
                COMPARE_RESULT=$?
            elif [[ "CKSUM_VALUE" == "$ACTUAL_VALUE"  ]]; then
                COMPARE_RESULT=0
            fi
                
            # Perform quick check, nopoint rebuilding link if its going to be the same
            # Also prevents danger that an already running processes requires the presence if this link
            # you dont want it dissappearing even for a millisecond just because you logged in
            [[ $COMPARE_RESULT -eq 0 ]] && FILE_MATCHES=true
                
            if [[ "$IS_MANAGED" == "true" ]]; then
                MANAGED_CKSUM=$(printf "%s\n" "${FILES_MANAGED}" | cut -d" " -f2)
                    
                [[ "$MANAGED_CKSUM" == "$ACTUAL_VALUE" ]] && META_MATCHES=true
            fi

        fi
            
        RM_FILE=true
        RM_ENTRY=true
        COPY_FILE=true
        ADD_ENTRY=true
            
        # Generally if the file exists it really doesnt matter, we create from scratch (cant delete if doesnt exist though)
        if [[ "${FILE_EXISTS}" == "false" ]]; then
            RM_FILE=false
        else
            
            if [[ "${FILE_MATCHES}" == "true" ]]; then
                    
                # No point removing a file that matches what we expect
                RM_FILE=false
                COPY_FILE=false
                    
                # If file is the same, and metadata is the same then no need to do anything
                if [[ "$META_MATCHES" == "true" ]]; then
                    
                    RM_ENTRY=false
                    ADD_ENTRY=false
                        
                fi
                
            else
                
                # File exists but not managed, dont touch it incase a developer put it there
                if [[ "$META_MATCHES" == "false" ]]; then
                    
                    RM_FILE=false
                    COPY_FILE=false
                    RM_ENTRY=false
                    ADD_ENTRY=false
                        
                fi
                
            fi
                
        fi
                    
        if [[ "${RM_ENTRY}" == "true" ]]; then
        
            # Remove the link, ready to rebuild
            ${DEBUG} && log_it DEBUG CLEANUP "grep -v '^${SHORT_NAME_SAFE} ' '${BASE_PATH}/.dotfile.managed' > '${BASE_PATH}/.dotfile.managed2'"
            grep -v "^${SHORT_NAME_SAFE} " "${BASE_PATH}/.dotfile.managed" > "${BASE_PATH}/.dotfile.managed2"
            if [[ $? -ne 0 ]]; then
                print_error "Could not remove file from role [%s]" "${ROLE_PATH}"
                return 4
            fi
            
            ${DEBUG} && log_it DEBUG CLEANUP "mv '${BASE_PATH}/.dotfile.managed2' '${BASE_PATH}/.dotfile.managed'"
            mv "${BASE_PATH}/.dotfile.managed2" "${BASE_PATH}/.dotfile.managed"
            if [[ $? -ne 0 ]]; then
                print_error "Could not add file to role [%s]" "${ROLE_PATH}"
                return 4
            fi
        
        fi
        
        if [[ "${RM_FILE}" == "true" ]]; then
        
            # Remove the link, ready to rebuild
            ${DEBUG} && log_it DEBUG CLEANUP "rm -f '${BASE_PATH}/${SHORT_NAME}'"
            rm -f "${BASE_PATH}/${SHORT_NAME}"
            if [[ $? -ne 0 ]]; then
                print_error "Could not remove file from role [%s]" "${ROLE_PATH}"
                return 4
            fi
        
        fi
        
        if [[ "${ADD_ENTRY}" == "true" ]]; then
        
            # Record that we are now managing this file
            ${DEBUG} && log_it DEBUG COPYING "printf '%s %s %s\n' '${SHORT_NAME}' '${ACTUAL_VALUE}' '${name}' >> '${BASE_PATH}/.dotfile.managed'"
            printf "%s %s %s\n" "${SHORT_NAME}" "${ACTUAL_VALUE}" "${name}" >> "${BASE_PATH}/.dotfile.managed"
            if [[ $? -ne 0 ]]; then
                print_error "Could not add metadata to [%s] to manage file copy from role [%s]" "${BASE_PATH}/${SHORT_NAME}" "${ROLE_PATH}"
                return 5
            fi
        
        fi
            
        if [[ "${COPY_FILE}" == "true" ]]; then
            
            ${DEBUG} && log_it DEBUG COPYING "cp --recursive --archive '${name}' '${BASE_PATH}/${SHORT_NAME}'"
            cp --recursive --archive "${name}" "${BASE_PATH}/${SHORT_NAME}"
            if [[ $? -ne 0 ]]; then
                print_error "Could not add file from role [%s]" "${ROLE_PATH}"
                return 5
            fi
                
        fi
            
    done
    
    return $SUCCESS
}

function setup_role_links
{
    NEW_ROLE=""
    ROLE_LIST=""

    USE_LINK=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role   ) NEW_ROLE="${my_arr[$i]}"
                       ;;
            --list   ) ROLE_LIST="${my_arr[$i]}"
                       ;;
        
            --link   ) USE_LINK="$var"
                       ;;
                       
        esac
        
    done
    
    # Quick exit
    [[ -z "$USE_LINK" ]] && return $SUCCESS

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_LINK="$ROLE_PATH/links"
    
    # First step is to create links if configured and the role contains them
    [[ ! -d "${ROLE_LINK}" ]] && return $SUCCESS
    
    
    # Find direct children
    TARGETS=$(find "$ROLE_LINK" -maxdepth 1 -mindepth 1 2>/dev/null)

    # Go through all the files/folders found in the links folder as we need to point to them as symbolic
    # links in the users home directory
    for name in ${TARGETS}; do
        
        # Escape the name of the link as will be used for egrep
        SHORT_NAME=$(basename "${name}")
        SHORT_NAME_SAFE=$(escape_regex_extended "${SHORT_NAME}")

        # Determines whether we need to create the link (ie we dont rebuild a link if it already exists)
        REBUILD_LINK=true
            
        # By default all links are created in the home directory unless overriden
        BASE_PATH=$(echo ~)
            
        LINKS_LIST=""
        CHMOD_PERMS=""
        CHOWN_USER=""
        CHOWN_RECURSIVE=false
        
        if [[ -f "$ROLE_PATH/meta" ]]; then
            
            # When building links you can chmod it as well, extract both information
            OVERRIDES=$(grep -iE "^(chmod|link|chown) ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta")

            CHMOD_PERMS=$(printf "%s\n" "${OVERRIDES}" | grep -i "^chmod " | head -1 | cut -d" " -f3)
            LINKS_LIST=$( printf "%s\n" "${OVERRIDES}" | grep -i "^link "  | head -1 | cut -d" " -f3)
            CHOWN_USER=$( printf "%s\n" "${OVERRIDES}" | grep -i "^chown " | head -1 | cut -d" " -f3)
            CHOWN_RECURSIVE=$( printf "%s\n" "${OVERRIDES}" | grep -i "^chown " | head -1 | cut -d" " -f4)
            
            [[ -n "${LINKS_LIST}" ]] && BASE_PATH="${LINKS_LIST}"
        fi
            
        # Check the link already exists, if it does we may need to repoint it
        if [[ -L "${BASE_PATH}/${SHORT_NAME}" ]]; then

            ORIG_TARGET=$(readlink --canonicalize "${BASE_PATH}/${SHORT_NAME}")
            NEW_TARGET=$( readlink --canonicalize "${name}")
                
            # Perform quick check, no point rebuilding link if its going to be the same
            # Also prevents danger that an already running process requires the presence of this link
            # you dont want it dissappearing even for a millisecond just because you logged in
            if [[ "${ORIG_TARGET}" == "${NEW_TARGET}" ]]; then
                REBUILD_LINK=false
            else
                
                # Remove the link, ready to rebuild
                ${DEBUG} && log_it DEBUG CLEANUP "rm -f '${BASE_PATH}/${SHORT_NAME}'"
                rm -f "${BASE_PATH}/${SHORT_NAME}"
                if [[ $? -ne 0 ]]; then
                    print_error "Could not reset symbolic links from role [%s]" "${ROLE_PATH}"
                    return $ERR_CREATE_LINK_FAILED
                fi
                    
            fi

        fi
            
        # Only create a link if there is nothing there i.e. above we only checked if a symbolic link existed that
        # needs repointing, however if a file is there then user must have wanted an override of their own
        # we do not delete user overrides
        if [[ "${REBUILD_LINK}" == "true" && ! -e "${BASE_PATH}/${SHORT_NAME}" ]]; then
            
            # Try creating the symbolic link
            ${DEBUG} && log_it DEBUG LINKING "ln -s '${name}' '${BASE_PATH}/${SHORT_NAME}'"
            ln -s "${name}" "${BASE_PATH}/${SHORT_NAME}"
            if [[ $? -ne 0 ]]; then
                print_error "Could not add symbolic links from role [%s]" "${ROLE_PATH}"
                return $ERR_CREATE_LINK_FAILED
            fi
            
            # If in the metadata the user also described permissions
            if [[ -n "$CHMOD_PERMS" ]]; then
            
                # Get the current permissions and if they are not the same then change them
                # NOTE we do not support logical u+w etc permissions, only octal
                CURR_PERMS=$(find "${BASE_PATH}" -mindepth 1 -maxdepth 1 -name "${SHORT_NAME}" -printf "%#m\n")
                if [[ -n "$CURR_PERMS" && "$CURR_PERMS" != "$CHMOD_PERMS" ]]; then
                
                    chmod "$CHMOD_PERMS" "${BASE_PATH}/${SHORT_NAME}"
                    if [[ $? -ne 0 ]]; then
                        print_error "Could not set permissions [%s] on symbolic links from role [%s]" "$CHMOD_PERMS" "${ROLE_PATH}"
                        return $ERR_CREATE_LINK_FAILED
                    fi
                    
                fi
                
            fi
            
            # If in the metadata the user also described ownership
            if [[ -n "$CHOWN_USER" ]]; then
            
                # Get the current permissions and if they are not the same then change them
                # NOTE we do not support logical u+w etc permissions, only octal
                CURR_USER=$(find "${BASE_PATH}" -mindepth 1 -maxdepth 1 -name "${SHORT_NAME}" -printf "%u:%g\n")
                if [[ -n "$CURR_USER" && "$CURR_USER" != "$CHOWN_USER" ]]; then
                
                    RECURSIVE=false
                    [[ "$CHOWN_RECURSIVE" == "true" ]] && RECURSIVE="-R"
                    
                    chown ${RECURSIVE} "$CHOWN_USER" "${BASE_PATH}/${SHORT_NAME}"
                    if [[ $? -ne 0 ]]; then
                        print_error "Could not set ownsership [%s] on symbolic links from role [%s]" "$CHOWN_USER" "${ROLE_PATH}"
                        return $ERR_CREATE_LINK_FAILED
                    fi
                    
                fi
                
            fi
                
        fi
            
    done
    
    return $SUCCESS
}

function setup_role_templates
{
    NEW_ROLE=""
    ROLE_LIST=""
    USE_TEMPLATES=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role      ) NEW_ROLE="${my_arr[$i]}"
                          ;;
            --list      ) ROLE_LIST="${my_arr[$i]}"
                          ;;
        
            --templates ) USE_TEMPLATES="$var"
                          ;;
                       
        esac
        
    done
    
    [[ -z "$USE_TEMPLATES" ]] && return $SUCCESS

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_TEMPLATES="$ROLE_PATH/templates"
    
    [[ ! -d "$ROLE_TEMPLATES" ]] && return $SUCCESS
    

    #  Find direct children
    TARGETS=$(find "$ROLE_TEMPLATES" -maxdepth 1 -mindepth 1 2>/dev/null)
    
    for name in ${TARGETS}; do
    
        SHORT_NAME=$(basename "${name}")
        SHORT_NAME_SAFE=$(escape_regex "${SHORT_NAME}")
        
        BASE_PATH=$(echo ~)
        TEMPLATE_STRATEGY="${DOTFILES_TEMPLATE_STRATEGY}"
        
        # Check if there is a role configuration file specifying overrides for the template strategy or its target location
        if [[ -f "$ROLE_PATH/meta"  ]]; then
        
            TEMPLATE_LIST=$( grep -v "^[tT][eE][mM][pP][lL][aA][tT][eE] ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3)
            TEMPLATE_STRAT=$(grep -v "^[tT][eE][mM][pP][lL][aA][tT][eE][-][sS][tT][rR][aA][tT][eE][gG][yY] ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3)
            
            [[ -n "${TEMPLATE_LIST}"  ]] && BASE_PATH="${TEMPLATE_LIST}"
            [[ -n "${TEMPLATE_STRAT}" ]] && TEMPLATE_STRATEGY="${TEMPLATE_STRAT}"
            
        fi
        
        # If we are basing the engine on the file extension then set strategy override appropriately
        if [[ "${TEMPLATE_STRATEGY:-auto}" == "auto" ]]; then
            FILE_EXTENSION="${SHORT_NAME##*.}"
            
            case "${FILE_EXTENSION}" in
            
                j2     ) TEMPLATE_STRATEGY="j2cli"
                         ;;
                jinja2 ) TEMPLATE_STRATEGY="jinja2"
                         ;;
                tmpl   ) TEMPLATE_STRATEGY="varrick"
                         ;;
                *      ) TEMPLATE_STRATEGY="shell"
                         ;;
                
            esac
        fi
    
        # Run the template engine, copying the file into the target directory
        case "${TEMPLATE_STRATEGY:-shell}" in
    
            shell   ) # Need to shell escape
                      NEW_SHORT_NAME=$(basename "${name}" .sh)
                      CONTENTS=$(cat "$name")
                      eval "echo \"${CONTENTS}\" > \"${BASE_PATH}/${NEW_SHORT_NAME}\""
                      ;;
            varrick ) varrick "${name}" "${BASE_PATH}/"
                      ;;
            jinja2  ) NEW_SHORT_NAME=$(basename "${name}" .j2)
                      jinja2 "${name}" > "${BASE_PATH}/${NEW_SHORT_NAME}"
                      ;;
            j2cli   ) NEW_SHORT_NAME=$(basename "${name}" .j2)
                      j2 "${name}" > "${BASE_PATH}/${NEW_SHORT_NAME}"
                      ;;
            *       ) print_error "Unknown template engine [%s] specified for [%s]" "${TEMPLATE_STRATEGY}" "$name"
                      return 78
                      ;;
        esac
        
    done

    return $SUCCESS
}

function teardown_role_aliases
{
    NEW_ROLE=""
    ROLE_LIST=""
    USE_ALIASES=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role   ) NEW_ROLE="${my_arr[$i]}"
                       ;;
            --list   ) ROLE_LIST="${my_arr[$i]}"
                       ;;
        
            --alias  ) USE_ALIASES="$var"
                       ;;
                       
        esac
        
    done
    
    [[ -z "$USE_ALIASES" ]] && return $SUCCESS

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_ALIASES="$ROLE_PATH/aliases"
    
    # Second step is to inherit any common dependencies if configured and there is a dependencies file
    [[ ! -f "$ROLE_ALIASES" ]] && return $SUCCESS
    
    
    # Cant use pipes as the while loop becomes a subshell in bash, variables etc are not exposed
    #read_config "$ROLE_ALIASES" | while read -r name value; do
        
    ALIASES=$(read_config "$ROLE_ALIASES" | reverse_lines | cut -d" " -f1)
        
    for ALIAS_DEF in ${ALIASES}; do
        
        unalias -- "${ALIAS_DEF}" 2>/dev/null
        # No point monitoring for error, alias wont be there
            
    done
    
    return $SUCCESS
}

function teardown_role_dependencies
{
    NEW_ROLE=""
    ROLE_LIST=""
    USE_ENV=""
    USE_LINK=""
    USE_DEPS=""
    USE_PATHS=""
    USE_FILES=""
    USE_ALIASES=""
    USE_SCRIPT=""
    USE_TEMPLATES=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role      ) NEW_ROLE="${my_arr[$i]}"
                          ;;
            --list      ) ROLE_LIST="${my_arr[$i]}"
                          ;;
        
            --alias     ) USE_ALIASES="$var"
                          ;;
            --files     ) USE_FILES="$var"
                          ;;
            --link      ) USE_LINK="$var"
                          ;;
            --env       ) USE_ENV="$var"
                          ;;
            --deps      ) USE_DEPS="$var"
                          ;;
            --path      ) USE_PATHS="$var"
                          ;;
            --script    ) USE_SCRIPT="$var"
                          ;;
            --templates ) USE_TEMPLATES="$var"
                          ;;
                       
        esac
        
    done
    
    [[ -z "$USE_DEPS" ]] && return $SUCCESS

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_DEPS="$ROLE_PATH/dependencies"
    
    # Second step is to inherit any common dependencies if configured and there is a dependencies file
    [[ ! -f "$ROLE_DEPS" ]] && return $SUCCESS
    
    
    DEPS_LIST=$(grep "^role " "$ROLE_DEPS" | sed 's/ /,/g' | reverse_lines)
        
    for DEP_ROLE in ${DEPS_LIST}; do
        ROLE_NAME=$(printf "%s\n" "${DEP_ROLE}" | cut -d, -f2)
            
        # Propogate command line options as we are calling the script again
        REVERSE_FUNC_SWITCHES=""
        [[ -z "$USE_ENV"       ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-env"
        [[ -z "$USE_LINK"      ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-link"
        [[ -z "$USE_PATHS"     ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-paths"
        [[ -z "$USE_FILES"     ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-files"
        [[ -z "$USE_ALIASES"   ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-aliases"
        [[ -z "$USE_SCRIPT"    ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-script"
        [[ -z "$USE_TEMPLATES" ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --no-templates"
        [[ "$DEBUG" == "true"  ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --debug"
        [[ "$TRACE" == "true"  ]] && REVERSE_FUNC_SWITCHES="${REVERSE_FUNC_SWITCHES} --trace"
            
            
        . $DOTFILES_HOME/bin/dotfile ${REVERSE_FUNC_SWITCHES} release "${ROLE_NAME}"
        if [[ $? -ne 0 ]]; then
            print_error "Could not remove dependency [%s] from role [%s]" "${ROLE_NAME}" "${NEW_ROLE}"
            return $ERR_DELETE_DEPENDENCY_FAILED
        fi
            
        # Reset input parameters, there is a chance that any script we source can change these values
        # so we reset just to make sure
        NEW_ROLE=""
        ROLE_LIST=""
        USE_ENV=""
        USE_LINK=""
        USE_DEPS=""
        USE_PATHS=""
        USE_FILES=""
        USE_ALIASES=""
        USE_SCRIPT=""
        USE_TEMPLATES=""
    
        i=0
        my_arr=("$@")
        for var in "$@"; do
    
            i=$(( i + 1 ))
        
            case "$var" in
        
                --role      ) NEW_ROLE="${my_arr[$i]}"
                              ;;
                --list      ) ROLE_LIST="${my_arr[$i]}"
                              ;;
        
                --alias     ) USE_ALIASES="$var"
                              ;;
                --files     ) USE_FILES="$var"
                              ;;
                --link      ) USE_LINK="$var"
                              ;;
                --env       ) USE_ENV="$var"
                              ;;
                --deps      ) USE_DEPS="$var"
                              ;;
                --path      ) USE_PATHS="$var"
                              ;;
                --script    ) USE_SCRIPT="$var"
                              ;;
                --templates ) USE_TEMPLATES="$var"
                              ;;
                       
            esac
        
        done
    
        NEW_ROLE_UPPER=$(printf "%s\n" "${NEW_ROLE}" | normalize_role)
            
        ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
        ROLE_MAIN="$ROLE_PATH"
        ROLE_LINK="${ROLE_PATH}/links"
        ROLE_DEPS="${ROLE_PATH}/dependencies"
        [[ -d "${ROLE_PATH}" ]] && ROLE_MAIN="${ROLE_PATH}/main"
            
    done
    
    return $SUCCESS
}

function teardown_role_environment
{
    NEW_ROLE=""
    ROLE_LIST=""
    USE_ENV=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role   ) NEW_ROLE="${my_arr[$i]}"
                       ;;
            --list   ) ROLE_LIST="${my_arr[$i]}"
                       ;;
        
            --env    ) USE_ENV="$var"
                       ;;
                       
        esac
        
    done

    # Quick exit
    [[ -z "$USE_ENV" ]] && return $SUCCESS

    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_ENV="$ROLE_PATH/env"

    [[ ! -f "$ROLE_ENV" ]] && return $SUCCESS


    # Need to remove the need for a while loop as this spawns a subshell in POSIX / bash so the exports arent exposed
    #read_config "$ROLE_ENV" | while read -r action name value; do
    LINES=$(grep -iE "^(set|prepend|append) " "$ROLE_ENV")
    PARAMS=$(printf "%s\n" "$LINES" | cut -d" " -f2)
    
    i=0
    for PARAM in ${PARAMS}; do
        
        i=$(( i + 1 ))
        
        # Escape for egrep
        PARAM_SAFE=$(escape_regex_extended "$PARAM")
        
        # Extract the exact line
        name="$PARAM"
        line=$(printf "%s\n" "$LINES" | head -${i} | tail -1)
        action=$( printf "%s\n" "$line" | cut -d" " -f1  | tr '[A-Z]' '[a-z]' )
        value=$(  printf "%s\n" "$line" | cut -d" " -f3- )
        new_value="$value"
            
        case "$action" in
            
            set     ) new_value=""
                
                      unset "${name}"
                      if [[ $? -ne 0 ]]; then
                          print_error "Could not unset environment variable [%s] from role [%s]" "${name}" "${ROLE_PATH}"
                          return $ERR_DELETE_ENV_FAILED
                      fi
                      ;;
            prepend ) #eval export ${name}=${value}${name}
                      value_interpreted=$(eval printf "%s" "${value}")
                      new_value=$(env | grep "^${name}=" | sed "s|^${name}=||g" | sed "s|^${value_interpreted}||g")
                          
                      export ${name}="$new_value"
                      if [[ $? -ne 0 ]]; then
                          print_error "Could not pop environment variable [%s] from role [%s]" "${name}" "${ROLE_PATH}"
                          return $ERR_DELETE_ENV_FAILED
                      fi
                      ;;
            append  ) #eval export ${name}=${value}${name}
                      value_interpreted=$(eval printf "%s" "${value}")
                      new_value=$(env | grep "^${name}=" | sed "s|^${name}=||g" | sed "s|${value_interpreted}$||g")
                          
                      export ${name}="$new_value"
                      if [[ $? -ne 0 ]]; then
                          print_error "Could not shift environment variable [%s] from role [%s]" "${name}" "${ROLE_PATH}"
                          return $ERR_DELETE_ENV_FAILED
                      fi
                      ;;
            
        esac
            
        # Check if user wants all unset variables to be unset or remain as blank
        if [[ "$DOTFILES_UNSET_EMPTY_VARIABLES" == "true" && -z "${new_value}" ]]; then
            unset "${name}"
        fi
            
    done
    
    return $SUCCESS
}

function teardown_role_script
{
    NEW_ROLE=""
    ROLE_LIST=""
    USE_ENV=""
    USE_LINK=""
    USE_DEPS=""
    USE_PATHS=""
    USE_FILES=""
    USE_ALIASES=""
    USE_SCRIPT=""
    USE_TEMPLATES=""
    FUNC_SWITCHES=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role      ) NEW_ROLE="${my_arr[$i]}"
                          ;;
            --list      ) ROLE_LIST="${my_arr[$i]}"
                          ;;
        
            --alias     ) USE_ALIASES="$var"
                          ;;
            --files     ) USE_FILES="$var"
                          ;;
            --link      ) USE_LINK="$var"
                          ;;
            --env       ) USE_ENV="$var"
                          ;;
            --deps      ) USE_DEPS="$var"
                          ;;
            --path      ) USE_PATHS="$var"
                          ;;
            --script    ) USE_SCRIPT="$var"
                          ;;
            --templates ) USE_TEMPLATES="$var"
                          ;;
                       
        esac
        
    done

    [[ -z "$USE_SCRIPT" ]] && return $SUCCESS

    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_MAIN="$ROLE_PATH"

    # Incase the base path is a directory then we assume there might be a main file/script
    [[ -d "${ROLE_PATH}" ]] && ROLE_MAIN="${ROLE_PATH}/main"

    [[ ! -f "$ROLE_MAIN" ]] && return $SUCCESS


    ${DEBUG} && log_it DEBUG CALL ". ${ROLE_MAIN} --teardown ${USE_ALIASES} ${USE_FILES} ${USE_LINK} ${USE_ENV} ${USE_DEPS} ${USE_PATHS} ${USE_SCRIPT} ${USE_TEMPLATES}"
    . "${ROLE_MAIN}" --teardown ${USE_ALIASES} ${USE_FILES} ${USE_LINK} ${USE_ENV} ${USE_DEPS} ${USE_PATHS} ${USE_SCRIPT} ${USE_TEMPLATES}

    if [[ $? -ne 0 ]]; then
        print_error "Could not release role [%s]" "${ROLE_PATH}"
        return 3
    fi
    
    return $SUCCESS
}

function teardown_role_paths
{
    NEW_ROLE=""
    ROLE_LIST=""

    USE_PATHS=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role   ) NEW_ROLE="${my_arr[$i]}"
                       ;;
            --list   ) ROLE_LIST="${my_arr[$i]}"
                       ;;
        
            --path   ) USE_PATHS="$var"
                       ;;
                       
        esac
        
    done

    [[ -z "$USE_PATHS" ]] && return $SUCCESS
    
    # Find the base path to the role and core files that MAY exist within it (or it might just be a file itself)
    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_BIN="$ROLE_PATH/bin"
    ROLE_LIB="$ROLE_PATH/lib"
    ROLE_FUN="$ROLE_PATH/funcs"
    
    DIRECTION_BIN=""
    DIRECTION_LIB=""
    DIRECTION_FUN=""

    if [[ -f "$ROLE_PATH/meta" ]]; then

        DIRECTION_BIN=$(grep -i "^path-method bin (append|prepend|none)\$" "$ROLE_PATH/meta"   | cut -d" " -f2 | tr '[A-Z]' '[a-z]')
        DIRECTION_LIB=$(grep -i "^path-method lib (append|prepend|none)\$" "$ROLE_PATH/meta"   | cut -d" " -f2 | tr '[A-Z]' '[a-z]')
        DIRECTION_FUN=$(grep -i "^path-method funcs (append|prepend|none)\$" "$ROLE_PATH/meta" | cut -d" " -f2 | tr '[A-Z]' '[a-z]')

    fi

    # BIN
    case "${DIRECTION_BIN:-prepend}" in

        prepend ) [[ -d "$ROLE_BIN" ]] && export PATH=$(printf "%s\n" "$PATH" | sed "s|^$ROLE_BIN:||g")
                  ;;
        append  ) [[ -d "$ROLE_BIN" ]] && export PATH=$(printf "%s\n" "$PATH" | sed "s|:?${ROLE_BIN}\$||g")
                  ;;
        none    ) ;;
        *       ) return 65
                  ;;

    esac

    # FPATH
    case "${DIRECTION_FUN:-prepend}" in

        prepend ) [[ -d "$ROLE_FUN" ]] && export FPATH=$(printf "%s\n" "$FPATH" | sed "s|^$ROLE_FUN:||g")
                  ;;
        append  ) [[ -d "$ROLE_FUN" ]] && export FPATH=$(printf "%s\n" "$FPATH" | sed "s|:?${ROLE_FUN}\$||g")
                  ;;
        none    ) ;;
        *       ) return 65
                  ;;

    esac

    # LD_LIBRARY_PATH
    case "${DIRECTION_LIB:-prepend}" in

        prepend ) [[ -d "$ROLE_LIB" ]] && export LD_LIBRARY_PATH=$(printf "%s\n" "$LD_LIBRARY_PATH" | sed "s|^$ROLE_LIB:||g")
                  ;;
        append  ) [[ -d "$ROLE_LIB" ]] && export LD_LIBRARY_PATH=$(printf "%s\n" "$LD_LIBRARY_PATH" | sed "s|:?${ROLE_LIB}\$||g")
                  ;;
        none    ) ;;
        *       ) return 65
                  ;;

    esac
    
    return $SUCCESS
}

function teardown_role_files
{
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Need to get this working
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    return $SUCCESS
    NEW_ROLE=""
    ROLE_LIST=""

    USE_FILES=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role   ) NEW_ROLE="${my_arr[$i]}"
                       ;;
            --list   ) ROLE_LIST="${my_arr[$i]}"
                       ;;
        
            --files  ) USE_FILES="$var"
                       ;;
                       
        esac
        
    done
    
    [[ -z "$USE_FILES" ]] && return $SUCCESS

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_FILE="$ROLE_PATH/files"
    
    # First step is to create links if configured and the role contains them
    [[ ! -d "${ROLE_FILE}" ]] && return $SUCCESS
    
    # Get all children files
    TARGETS=$(find "$ROLE_FILE" -maxdepth 1 -mindepth 1 2>/dev/null | reverse_lines)
        
    # Go through all the files/folders found in the links folder as we need to point to them as symbolic
    # links in the users home directory
    for name in ${TARGETS}; do
        
        SHORT_NAME=$(basename "${name}")
            
        BASE_PATH=$(echo ~)
            
        FILES_LIST=""
        [[ -f "$ROLE_PATH/meta" ]] && FILES_LIST=$(grep -v "^[fF][iI][lL][eE] ${SHORT_NAME} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3)
        [[ -n "${FILES_LIST}" ]] && BASE_PATH="${FILES_LIST}"
            
        FILES_MANAGED=$(grep -v "^${SHORT_NAME} " "${BASE_PATH}/.dotfile.managed")
        ACTUAL_VALUE="-"
            
        # Determines whether we need to copy the file (ie we dont copy a file if it already exists)
        FILE_EXISTS=false
        IS_MANAGED=false
        FILE_MATCHES=false
        META_MATCHES=false
            
        [[ -f "${BASE_PATH}/${SHORT_NAME}" ]] && FILE_EXISTS=true
        [[ -n "${FILES_MANAGED}" ]] && IS_MANAGED=true
            
        # If we appear to have a copy of the file already we check the contents if we can
        if ${FILE_EXISTS}; then

            # Get the cksum for comparison if user requests it
            CKSUM_METHOD=""
            CKSUM_VALUE=""
            if [[ -f "$ROLE_PATH/meta" ]]; then
                CKSUM_METHOD=$(grep -v "^[hH][aA][sS][hH] ${SHORT_NAME} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3 | tr '[A-Z]' '[a-z]' )
                CKSUM_VALUE=$( grep -v "^[hH][aA][sS][hH] ${SHORT_NAME} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f4-)
            fi
                
            case "${CKSUM_METHOD}" in
                
                sha1sum   ) ACTUAL_VALUE=$(sha1sum   "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                sha224sum ) ACTUAL_VALUE=$(sha224sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                sha256sum ) ACTUAL_VALUE=$(sha256sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                sha384sum ) ACTUAL_VALUE=$(sha384sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                sha512sum ) ACTUAL_VALUE=$(sha512sum "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                md5sum    ) ACTUAL_VALUE=$(md5sum    "${BASE_PATH}/${SHORT_NAME}" 2>/dev/null | cut -d" " -f1) 
                            ;;
                force     ) ACTUAL_VALUE="force"
                            ;;
                skip      ) ACTUAL_VALUE="skip"
                            ;;
                
            esac
                
            COMPARE_RESULT=1
                
            if [[ "$ACTUAL_VALUE" == "force" ]]; then
                COMPARE_RESULT=1
            elif [[ "$ACTUAL_VALUE" == "skip" ]]; then
                COMPARE_RESULT=0
            elif [[ -z "${ACTUAL_VALUE}" || "${ACTUAL_VALUE}" == "-" ]]; then 
                cmp "${BASE_PATH}/${SHORT_NAME}" "${name}" 2>/dev/null
                COMPARE_RESULT=$?
            elif [[ "CKSUM_VALUE" == "$ACTUAL_VALUE"  ]]; then
                COMPARE_RESULT=0
            fi
                
            # Perform quick check, nopoint rebuilding link if its going to be the same
            # Also prevents danger that an already running processes requires the presence if this link
            # you dont want it dissappearing even for a millisecond just because you logged in
            [[ $COMPARE_RESULT -eq 0 ]] && FILE_MATCHES=true
                
            if [[ "$IS_MANAGED" == "true" ]]; then
                MANAGED_CKSUM=$(printf "%s\n" "${FILES_MANAGED}" | cut -d" " -f2)
                    
                [[ "$MANAGED_CKSUM" == "$ACTUAL_VALUE" ]] && META_MATCHES=true
            fi

        fi
            
        RM_FILE=true
        RM_ENTRY=true
            
        # Generally if the file exists it really doesnt matter, we create from scratch (cant delete if doesnt exist though)
        if [[ "${FILE_EXISTS}" == "false" ]]; then
            RM_FILE=false
        else
            
            if [[ "${FILE_MATCHES}" == "true" ]]; then
                    
                # No point removing a file that matches what we expect
                RM_FILE=false
                COPY_FILE=false
                    
                # If file is the same, and metadata is the same then no need to do anything
                if [[ "$META_MATCHES" == "true" ]]; then
                    
                    RM_ENTRY=false
                    ADD_ENTRY=false
                        
                fi
                
            else
                
                # File exists but not managed, dont touch it incase a developer put it there
                if [[ "$META_MATCHES" == "false" ]]; then
                    
                    RM_FILE=false
                    COPY_FILE=false
                    RM_ENTRY=false
                    ADD_ENTRY=false
                        
                fi
                
            fi
                
        fi
                    
        if [[ "${RM_ENTRY}" == "true" ]]; then
                
            # Remove the link, ready to rebuild
            ${DEBUG} && log_it DEBUG CLEANUP "grep -v '^${SHORT_NAME} ' '${BASE_PATH}/.dotfile.managed' > '${BASE_PATH}/.dotfile.managed2'"
            grep -v "^${SHORT_NAME} " "${BASE_PATH}/.dotfile.managed" > "${BASE_PATH}/.dotfile.managed2"
            if [[ $? -ne 0 ]]; then
                print_error "Could not add remove file from role [%s]" "${ROLE_PATH}"
                return 4
            fi
                
            ${DEBUG} && log_it DEBUG CLEANUP "mv '${BASE_PATH}/.dotfile.managed2' '${BASE_PATH}/.dotfile.managed'"
            mv "${BASE_PATH}/.dotfile.managed2" "${BASE_PATH}/.dotfile.managed"
            if [[ $? -ne 0 ]]; then
                print_error "Could not add file from role [%s]" "${ROLE_PATH}"
                return 4
            fi
                
        fi
            
        if [[ "${RM_FILE}" == "true" ]]; then
                
            # Remove the link, ready to rebuild
            ${DEBUG} && log_it DEBUG CLEANUP "rm -f '${BASE_PATH}/${SHORT_NAME}'"
            rm -f "${BASE_PATH}/${SHORT_NAME}"
            if [[ $? -ne 0 ]]; then
                print_error "Could not remove file from role [%s]" "${ROLE_PATH}"
                return 4
            fi
                
        fi
            
        if [[ "${ADD_ENTRY}" == "true" ]]; then
                
            # Record that we are now managing this file
            ${DEBUG} && log_it DEBUG COPYING "printf '%s %s %s\n' '${SHORT_NAME}' '${ACTUAL_VALUE}' '${name}' >> '${BASE_PATH}/.dotfile.managed'"
            printf "%s %s %s\n" "${SHORT_NAME}" "${ACTUAL_VALUE}" "${name}" >> "${BASE_PATH}/.dotfile.managed"
            if [[ $? -ne 0 ]]; then
                print_error "Could not add metadata to [%s] to manage file copy from role [%s]" "${BASE_PATH}/${SHORT_NAME}" "${ROLE_PATH}"
                return 5
            fi
                
        fi
            
        if [[ "${COPY_FILE}" == "true" ]]; then
            
            ${DEBUG} && log_it DEBUG COPYING "cp --recursive --archive '${name}' '${BASE_PATH}/${SHORT_NAME}'"
            cp --recursive --archive "${name}" "${BASE_PATH}/${SHORT_NAME}"
            if [[ $? -ne 0 ]]; then
                print_error "Could not add file from role [%s]" "${ROLE_PATH}"
                return 5
            fi
                
        fi
            
    done
    
    return $SUCCESS
}

function teardown_role_links
{
    NEW_ROLE=""
    ROLE_LIST=""

    USE_LINK=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role   ) NEW_ROLE="${my_arr[$i]}"
                       ;;
            --list   ) ROLE_LIST="${my_arr[$i]}"
                       ;;
        
            --link   ) USE_LINK="$var"
                       ;;
                       
        esac
        
    done
    
    [[ -z "$USE_LINK" ]] && return $SUCCESS

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_LINK="$ROLE_PATH/links"
    
    # First step is to create links if configured and the role contains them
    [[ ! -d "${ROLE_LINK}" ]] && return $SUCCESS
    
    
    # Look at direct children
    TARGETS=$(find "$ROLE_LINK" -maxdepth 1 -mindepth 1 2>/dev/null | reverse_lines)
        
    # Go through all the files/folders found in the links folder as we need to point to them as symbolic
    # links in the users home directory
    for name in ${TARGETS}; do
        
        SHORT_NAME=$(basename "${name}")
        SHORT_NAME_SAFE=$(escape_regex "${SHORT_NAME}")

        BASE_PATH=$(echo ~)
        LINKS_LIST=""
            
        # Check if there is a role configuration file redirecting this link
        [[ -f "$ROLE_PATH/meta" ]] && LINKS_LIST=$(grep -v "^[lL][iI][nN][kK] ${SHORT_NAME_SAFE} " "$ROLE_PATH/meta" | head -1 | cut -d" " -f3)
        [[ -n "${LINKS_LIST}"   ]] && BASE_PATH="${LINKS_LIST}"
            
        # Check if link already exists, if so, remove it
        if [[ -L "${BASE_PATH}/${SHORT_NAME}" ]]; then

            "${DEBUG}" && log_it DEBUG CLEANUP "rm -f '${BASE_PATH}/${SHORT_NAME}'"
            rm -f "${BASE_PATH}/${SHORT_NAME}"
            if [[ $? -ne 0 ]]; then
                print_error "Could not reset symbolic links from role [%s]" "${ROLE_PATH}"
                return 4
            fi

        fi
            
    done
    
    return $SUCCESS
}

function teardown_role_templates
{
    NEW_ROLE=""
    ROLE_LIST=""
    
    USE_TEMPLATES=""
    
    i=0
    my_arr=("$@")
    for var in "$@"; do
    
        i=$(( i + 1 ))
        
        case "$var" in
        
            --role      ) NEW_ROLE="${my_arr[$i]}"
                          ;;
            --list      ) ROLE_LIST="${my_arr[$i]}"
                          ;;
        
            --templates ) USE_TEMPLATES="$var"
                          ;;
                       
        esac
        
    done
    
    [[ -z "$USE_TEMPLATES" ]] && return $SUCCESS

    ROLE_PATH=$( get_role_path "${NEW_ROLE}" "$ROLE_LIST" )
    ROLE_TEMPLATES="$ROLE_PATH/templates"
    
    [[ ! -d "$ROLE_TEMPLATES" ]] && return $SUCCESS
    
    
    return $SUCCESS
}


#-- Includes -------------------------------------------------------------------------------------------------------

([[ -n $ZSH_EVAL_CONTEXT && $ZSH_EVAL_CONTEXT =~ :file$ ]] || 
 [[ -n $KSH_VERSION && $(cd "$(dirname -- "$0")" &&
    printf '%s' "${PWD%/}/")$(basename -- "$0") != "${.sh.file}" ]] || 
 [[ -n $BASH_VERSION && $0 != "$BASH_SOURCE" ]]) && leave=return || leave=exit

# Default to current directory if environment not set
if [[ -z "$DOTFILES_HOME" ]]; then
    DOTFILES_HOME="$PWD"
fi

# Give the user a chance to define env variables then take system defaults
if [[ -n "${DOTFILES_CONFIG}" ]]
then
    if [[ -f "${DOTFILES_CONFIG}" ]]; then
        . "${DOTFILES_CONFIG}"
        if [[ $? -ne 0 ]]
        then
            print_error "Could not source '%s'.  This is defined in the environment variable %s.  Exiting" "$DOTFILES_CONFIG" DOTFILES_CONFIG
            ${leave} $ERR_FAILED_LOADING_CONFIG
        fi
    else
        print_error "Could not source '%s'.  This is defined in the environment variable %s but does not exist.  Exiting" "$DOTFILES_CONFIG" DOTFILES_CONFIG
        ${leave} $ERR_FAILED_LOADING_CONFIG
    fi
fi

# Check if user has this in their home directory
if [[ -f "~/.dotfiles.cfg" ]]
then
    . "~/.dotfiles.cfg"
    if [[ $? -ne 0 ]]
    then
        print_error "Could not source '%s'.  Exiting" "~/.dotfiles.cfg"
        ${leave} $ERR_FAILED_LOADING_CONFIG
    fi
fi

if [[ -f "$DOTFILES_HOME/etc/dotfiles.cfg" ]]
then
    . "$DOTFILES_HOME/etc/dotfiles.cfg"
    if [[ $? -ne 0 ]]
    then
        print_error "Could not source '%s'.  Exiting" "${DOTFILES_HOME}/etc/dotfiles.cfg"
        ${leave} $ERR_FAILED_LOADING_CONFIG
    fi
fi

if [[ -f "$DOTFILES_ADMIN_CONFIG" ]]
then
    . "$DOTFILES_ADMIN_CONFIG"
    if [[ $? -ne 0 ]]
    then
        print_error "Could not source '%s'.  Exiting" "${DOTFILES_ADMIN_CONFIG}"
        ${leave} $ERR_FAILED_LOADING_CONFIG
    fi
fi


#-- Logging ---------------------------------------------------------------------------------------------------------

# Give a sane default if not defined
if [[ -z "$DOTFILES_LOG" ]]; then
    DOTFILES_LOG="$DOTFILES_HOME/log"
fi

# Check if the log is writeable
if [[ ! -r "$DOTFILES_LOG" ]]; then
    print_error "The value of %s [%s] is not readable.  Exiting" DOTFILES_LOG "$DOTFILES_LOG"
    ${leave} $ERR_INVALID_LOG_PATH
fi

# Check if the log is writeable
if [[ ! -w "$DOTFILES_LOG" ]]; then
    print_error "The value of %s [%s] is not writeable.  Exiting" DOTFILES_LOG "$DOTFILES_LOG"
    ${leave} $ERR_INVALID_LOG_PATH
fi

PREFIXED=""
[[ "${leave}" == "return" ]] && PREFIXED=". "
log_it INFO PARAMS "${PREFIXED}dotfile $@"
if [[ $? -ne 0 ]]; then
    print_error "Could not write to %s [%s] is not a valid file.  Exiting" DOTFILES_LOG "$DOTFILES_LOG"
    ${leave} $ERR_INVALID_LOG_PATH
fi


#-- Main -----------------------------------------------------------------------------------------------------------

USE_DEPS="${DOTFILES_INCLUDE_DEPENDENCIES:-true}"   # Do we include role dependencies
USE_ENV="${DOTFILES_INCLUDE_ENV:-true}"             # Do we include role environments
USE_LINK="${DOTFILES_INCLUDE_LINKS:-true}"          # Do we built symbolic links if required
USE_PATHS="${DOTFILES_INCLUDE_PATHS:-true}"         # Do we build paths if required
USE_FILES="${DOTFILES_INCLUDE_FILES:-true}"         # Do we copy files if required
USE_ALIASES="${DOTFILES_INCLUDE_ALIASES:-true}"     # Do we instantiate aliases
USE_SCRIPT="${DOTFILES_INCLUDE_SCRIPT:-true}"       # Do we include role environments / scripts
USE_TEMPLATES="${DOTFILES_INCLUDE_TEMPLATES:-true}" # Do we evaluate templates

DEBUG="${DOTFILES_DEBUG:-false}"                    # Debug messages to log output
TRACE=false                                         # Trace is purely at a user level
FORCE_HIDDEN=false                                  # Force requests for hidden roles

HASTTY=true
tty -s
[[ $? -ne 0 ]] && HASTTY=false                      # Helper variable to determine whether we have an interactive user


while [[ $# -ne 0 ]]; do

    case "$1" in

        -A | --no-aliases      ) shift; USE_ALIASES=false
                                 ;;
        -F | --no-files        ) shift; USE_FILES=false
                                 ;;
        -K | --no-link         ) shift; USE_LINK=false
                                 ;;
        -N | --no-env          ) shift; USE_ENV=false
                                 ;;
        -D | --no-dependencies ) shift; USE_DEPS=false
                                 ;;
        -P | --no-paths        ) shift; USE_PATHS=false
                                 ;;
        -S | --no-script       ) shift; USE_SCRIPT=false
                                 ;;
        -T | --no-templates    ) shift; USE_TEMPLATES=false
                                 ;;
        -f | --force           ) shift; FORCE_HIDDEN=true
                                 ;;
        -x | --debug           ) shift; DEBUG=true
                                 ;;
        -X | --trace           ) shift; DEBUG=true; TRACE=true
                                 set -xv
                                 ;;
        -h | --help            ) usage
                                 ${leave} $SUCCESS
                                 ;;
        *                      ) break
                                 ;;

    esac

done


# Normalize the above options into switches, this makes passing to functions much cleaner and easier
if [[ "$USE_DEPS"      == "true" ]]; then USE_DEPS="--deps";           else USE_DEPS="";      fi
if [[ "$USE_ENV"       == "true" ]]; then USE_ENV="--env";             else USE_ENV="";       fi
if [[ "$USE_LINK"      == "true" ]]; then USE_LINK="--link";           else USE_LINK="";      fi
if [[ "$USE_PATHS"     == "true" ]]; then USE_PATHS="--path";          else USE_PATHS="";     fi
if [[ "$USE_FILES"     == "true" ]]; then USE_FILES="--files";         else USE_FILES="";     fi
if [[ "$USE_ALIASES"   == "true" ]]; then USE_ALIASES="--alias";       else USE_ALIASES="";   fi
if [[ "$USE_SCRIPT"    == "true" ]]; then USE_SCRIPT="--script";       else USE_SCRIPT="";    fi
if [[ "$USE_TEMPLATES" == "true" ]]; then USE_TEMPLATES="--templates"; else USE_TEMPLATES=""; fi


# Check we have the right amount of parameters left
if [[ $# -lt 2 ]]; then
    if [[ $# -lt 1 || ( "$1" != "list" && "$1" != "reset" && "$1" != "status" ) ]]; then
        usage >&2
        ${leave} $ERR_UNKNOWN_CMD
    fi
fi

MAIN_CMD="$1"
shift

# Basic validation and executing high level commands that dont require environment manipulation
case "$MAIN_CMD" in

    request            ) ;;
    release            ) ;;
    reset              ) ;;
    describe           ) ;;
    list               ) ;;
    status             ) ;;
    help               ) ;;
    -h | --help        ) usage
                         ${leave} $SUCCESS
                         ;;
    *                  ) usage >&2
                         ${leave} $ERR_UNKNOWN_CMD
                         ;;

esac

# Find all roles installed on the machine / in known paths
ROLE_LIST=$( list_roles "${DOTFILES_ROLES_PATH}" )

# Very lightweight functionality that doesnt need to know of current role state etc
case "$MAIN_CMD" in

    list   ) printf "%s\n" "${ROLE_LIST}"
             ${leave} $SUCCESS
             ;;
    status ) print_status
             ${leave} $SUCCESS
             ;;

esac

# Further commands interact directly with an already allocated role or a specific one that needs querying, reset is an exception as it has no arguments
# however due to its implementation We call it like any other
NEW_ROLE=$(        printf "%s\n" "$1" | cut -d":" -f1)
NEW_ROLE_ACTION=$( printf "%s\n" "$1" | cut -d":" -f2)
[[ "$MAIN_CMD" != "reset" ]] && shift


case "$MAIN_CMD" in

    describe           ) describe_role "$NEW_ROLE" "$NEW_ROLE_ACTION" "$ROLE_LIST" ${USE_ALIASES} ${USE_FILES} ${USE_LINK} ${USE_ENV} ${USE_DEPS} ${USE_PATHS} ${USE_SCRIPT} ${USE_TEMPLATES}
                         ${leave} $?
                         ;;
    help               ) help_role "$NEW_ROLE"
                         ${leave} $?
                         ;;
    
esac


RC=$SUCCESS

# We perform this seperately than the above so that we arent modifying environment variables simply because we've been asked to describe something
export DOTFILES_ALLOCATION_INDEX="${DOTFILES_ALLOCATION_INDEX:-0}"

# Basic validation
case "$MAIN_CMD" in

    request            ) request_role  "$NEW_ROLE" "$NEW_ROLE_ACTION" "$ROLE_LIST" ${USE_ALIASES} ${USE_FILES} ${USE_LINK} ${USE_ENV} ${USE_DEPS} ${USE_PATHS} ${USE_SCRIPT} ${USE_TEMPLATES}
                         RC=$?
                         ;;
    release            ) release_role  "$NEW_ROLE" "$NEW_ROLE_ACTION" "$ROLE_LIST" ${USE_ALIASES} ${USE_FILES} ${USE_LINK} ${USE_ENV} ${USE_DEPS} ${USE_PATHS} ${USE_SCRIPT} ${USE_TEMPLATES}
                         RC=$?
                         ;;
    reset              ) release_role  "@"         "$NEW_ROLE_ACTION" "$ROLE_LIST" ${USE_ALIASES} ${USE_FILES} ${USE_LINK} ${USE_ENV} ${USE_DEPS} ${USE_PATHS} ${USE_SCRIPT} ${USE_TEMPLATES}
                         RC=$?
                         ;;
    
esac

# Remove if becomes unnecessary
[[ "${DOTFILES_ALLOCATION_INDEX}" -le 0 ]] && unset DOTFILES_ALLOCATION_INDEX

${leave} $RC
